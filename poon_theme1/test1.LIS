

   1               	        .data
   2               	        .align 2
   3               	environ:
   4 0000 0000 0000 	        .long 0
   5               	 	.align	2
   6               	
   7               	.extern main
   8               	.extern exit
   9               	.extern monitor_begin
  10               	.extern hardware_init_hook
  11               	.extern software_init_hook
  12               	.extern atexit
  13               	.extern __do_global_dtors
  14               	.extern __bss_start
  15               	.extern _end
  16               	
  17               	.global start
  18               	
  19               	.text
  20               	.even
  21               		/* See if user supplied their own stack (__stack != 0).  If not, then
  22               		 * default to using the value of %sp as set by the ROM monitor.
  23               		 */
  24 0000 207C 0000 		movel	#__stack, %a0
  24      0000 
  25 0006 B1FC 0000 		cmpl	#0, %a0
  25      0000 
  26 000c 6702      		jbeq    1f
  27 000e 2E48      		movel	%a0, %sp
  28               	1:
  29               		/* set up initial stack frame */
  30 0010 4E56 FFF8 		link	%a6, #-8
  31               	
  32               		/* zero out the bss section */
  33 0014 223C 0000 		movel	#__bss_start, %d1
  33      0000 
  34 001a 203C 0000 		movel	#_end, %d0
  34      0000 
  35 0020 B280      		cmpl	%d0, %d1
  36 0022 6712      		jbeq	3f
  37 0024 2041      		movl	%d1, %a0
  38 0026 9081      		subl	%d1, %d0
  39 0028 5380      		subql	#1, %d0
  40               	2:
  41 002a 4218      		clrb	(%a0)+
  42 002c 51C8 FFFC 		dbra	%d0, 2b
  43 0030 4240      		clrw	%d0
  44 0032 5380      		subql	#1, %d0
  45 0034 64F4      		jbcc	2b
  46               	3:
  47               		/* jmp monitor initialize after making up  bss */
  48 0036 4EF9 0000 		jmp	monitor_begin
  48      0000 
  49               	start:
  50               		/* monitor returns here.
  51               		 * re-setup stack for C programs.
  52               	         * See if user supplied their own stack (__stack != 0).  If not, then


  53               		 * default to using the value of %sp as set by the ROM monitor.
  54               		 */
  55 003c 207C 0000 		movel	#__stack, %a0
  55      0000 
  56 0042 B1FC 0000 		cmpl	#0, %a0
  56      0000 
  57 0048 6702      		jbeq    skip
  58 004a 2E48      		movel	%a0, %sp
  59               	skip:
  60               		/* set up initial stack frame */
  61 004c 4E56 FFF8 		link	%a6, #-8
  62               	
  63               		/*
  64               		 * initialize target specific stuff. Only execute these
  65               		 * functions it they exist.
  66               		 */
  67 0050 41F9 0000 		lea	hardware_init_hook, %a0
  67      0000 
  68 0056 B1FC 0000 		cmpl	#0, %a0
  68      0000 
  69 005c 6702      		jbeq	4f
  70 005e 4E90      		jsr     (%a0)
  71               	4:
  72 0060 41F9 0000 		lea	software_init_hook, %a0
  72      0000 
  73 0066 B1FC 0000 		cmpl	#0, %a0
  73      0000 
  74 006c 6702      		jbeq	5f
  75 006e 4E90      		jsr     (%a0)
  76               	5:
  77               	
  78               		/*
  79               		 * call the main routine from the application to get it going.
  80               		 * main (argc, argv, environ)
  81               		 * we pass argv as a pointer to NULL.
  82               		 */
  83               	
  84               		/* put __do_global_dtors in the atexit list so 
  85               		 * the destructors get run */
  86               	/* 
  87               		movel	#__do_global_dtors,(%sp)
  88               		jsr	atexit
  89               		movel	#__FINI_SECTION__,(%sp)
  90               		jsr	atexit
  91               		jsr	__INIT_SECTION__
  92               	*/
  93               		
  94               		** setup argv, argc and jump into main
  95 0070 4878 0000 	        pea     0
  96 0074 4879 0000 	        pea     environ
  96      0000 
  97 007a 486F 0004 	        pea     %sp@(4)
  98 007e 4878 0000 	        pea     0
  99 0082 4EB9 0000 		jsr	main
  99      0000 
 100 0088 2F00      		movel	%d0, %sp@-
 101               	


 102 008a 4EB9 0000 	        jsr     exit
 102      0000 
 103               	.even




   1               	.extern start
   2               	.global monitor_begin
   3               	
   4               	********************
   5               	** System call numbers 
   6               	******************** 
   7               	    .equ    SYSCALL_NUM_GETSTRING, 1 
   8               	    .equ    SYSCALL_NUM_PUTSTRING, 2 
   9               	    .equ    SYSCALL_NUM_RESET_TIMER, 3 
  10               	    .equ    SYSCALL_NUM_SET_TIMER, 4 
  11               	
  12               	******************************
  13               	** Head of the Register Group
  14               	*******************************
  15               	    .equ    REGBASE, 0xFFF000 | DMAP is used.
  16               	    .equ    IOBASE, 0x00d00000
  17               	*******************************
  18               	** Registers Related to Interrupts
  19               	*******************************
  20               	    .equ    IVR, REGBASE+0x300 | Interrupt Vector Register
  21               	    .equ    IMR, REGBASE+0x304 | Interrupt Mask Register
  22               	    .equ    ISR, REGBASE+0x30c | Interrupt Status Register
  23               	    .equ    IPR, REGBASE+0x310 | Interrupt Pending Register
  24               	*******************************
  25               	** Registers Related to the Timer
  26               	*******************************
  27               	    .equ    TCTL1, REGBASE+0x600 	|Timer1 Control Register
  28               	    .equ    TPRER1, REGBASE+0x602 	|Timer1 Prescaler Register
  29               	    .equ    TCMP1, REGBASE+0x604 	|Timer1 Compare Register
  30               	    .equ    TCN1, REGBASE+0x608 	|Timer1 Counter Register
  31               	    .equ    TSTAT1, REGBASE+0x60a 	|Timer1 Status Register
  32               	*******************************
  33               	** Registers Related to UART1 (Transmitter and Receiver)
  34               	*******************************
  35               	    .equ    USTCNT1, REGBASE+0x900 	|UART1 Status / Control Register
  36               	    .equ    UBAUD1, REGBASE+0x902 	| UART 1 Baud Control Register
  37               	    .equ    URX1, REGBASE+0x904 	| UART 1 Receiver register
  38               	    .equ    UTX1, REGBASE+0x906 	| UART 1 Transmitter Register
  39               	*******************************
  40               	** LED
  41               	*******************************
  42               	    .equ    LED7, IOBASE+0x000002f 	| Register for LED mounted on the board
  43               	    .equ    LED6, IOBASE+0x000002d 	| Refer to Appendix A.4.3.1 for a way to use
  44               	    .equ    LED5, IOBASE+0x000002b
  45               	    .equ    LED4, IOBASE+0x0000029
  46               	    .equ    LED3, IOBASE+0x000003f
  47               	    .equ    LED2, IOBASE+0x000003d
  48               	    .equ    LED1, IOBASE+0x000003b
  49               	    .equ    LED0, IOBASE+0x0000039
  50               	    .equ    PUSHSW, 0xFFF419 		| Register for Push Switch mounted on the board
  51               	****************************************************************
  52               	** Reservation of the stack region
  53               	****************************************************************
  54               	.section .bss
  55               	.even
  56               	SYS_STK:
  57 0000 0000 0000 	    .ds.b   0x4000  | System stack region


  57      0000 0000 
  57      0000 0000 
  57      0000 0000 
  57      0000 0000 
  58               	    .even
  59               	SYS_STK_TOP:        | End of the system stack region
  60               	****************************************************************
  61               	** Initialization
  62               	** A specific value has been set to internal device registers.
  63               	** Refer to each register specification in Appendix B to know the above reason.
  64               	****************************************************************
  65               	.section .text
  66               	.even
  67               	
  68               	monitor_begin :
  69               	
  70               	* Prohibit an interrupt into the supervisor and during performing various settings.
  71 0000 46FC 2700 	    move.w  #0x2700, %SR	    | run at lv.0
  72 0004 4FF9 0000 	    lea.l   SYS_STK_TOP, %SP  	    | Set SSP
  72      0000 
  73               	******************************
  74               	**Initialization of the interrupt controller
  75               	******************************
  76 000a 13FC 0040 	    move.b  #0x40, IVR                  | Set the user interrupt vector number to 0x40+level.
  76      00FF F300 
  77 0012 23FC 00FF 	    move.l  #0x00ff3ff9, IMR            | Allow UART1 and timer interrupts
  77      3FF9 00FF 
  77      F304 
  78 001c 21FC 0000 	    move.l  #SYSCALL, 0x080             | Set the interrupt for system call TRAP #0
  78      0000 0080 
  79 0024 21FC 0000 	    move.l  #INTERFACE, 0x110           | Set the interrupt subroutine for level 4 interrupt
  79      0000 0110 
  80 002c 21FC 0000 	    move.l  #TIMER_INTERRUPT, 0x118     | Set the interrupt subroutine for level 6 interrupt
  80      0000 0118 
  81               	******************************
  82               	** Initialization related to the transmitter and the receiver (UART1)
  83               	** (The interrupt level has been fixed to 4.)
  84               	******************************
  85 0034 33FC 0000 	    move.w  #0x0000, USTCNT1 | Reset
  85      00FF F900 
  86 003c 33FC E10C 	    move.w  #0xe10c, USTCNT1 | Transmission and reception possible - no parity, 1 stop, 8 bit, allo
  86      00FF F900 
  87 0044 33FC 0038 	    move.w  #0x0038, UBAUD1  | baud rate = 230400 bps
  87      00FF F902 
  88               	*************************
  89               	** Initialization related to the timer (The interrupt level has been fixed to 6.)
  90               	*************************
  91 004c 33FC 0004 	    move.w  #0x0004, TCTL1  | Restart, an interrupt impossible
  91      00FF F600 
  92               	                            | Count the time with the 1/16 of the system clock
  93               	                            | as a unit
  94               	                            | Stop the timer use
  95 0054 4EBA 023A 	    jsr		INIT_Q
  96 0058 46FC 2000 	    move.w	#0x2000, %SR	/* supervisoe mode, lv.0 */	
  97 005c 4EF9 0000 	    jmp 	start		
  97      0000 
  98               	    


  99               	****************************************************************
 100               	**    Program region
 101               	****************************************************************
 102               	MAIN:
 103               	    ** Set the running mode and the level (The process to move to 'the user mode')
 104 0062 46FC 0000 	    move.w	#0x0000, %SR		/*USER MODE, LEVEL 0*/
 105 0066 4FF9 0000 	    lea.l	USR_STK_TOP, %SP	/*set user stack*/
 105      0000 
 106               	    
 107               	    ** Start up RESET_TIMER by the system call
 108 006c 7003      	    move.l	#SYSCALL_NUM_RESET_TIMER, %d0
 109 006e 4E40      	    trap	#0
 110               		
 111               	    ** Start up SET_TIMER by the system call
 112 0070 7004      	    move.l	#SYSCALL_NUM_SET_TIMER, %d0
 113 0072 323C C350 	    move.w	#50000, %d1
 114 0076 243C 0000 	    move.l	#TT, %d2
 114      0000 
 115 007c 4E40      	    trap	#0
 116               	
 117               	
 118               	************************************* 
 119               	*    Test of sys_GETSTRING and sys_PUTSTRING 
 120               	*    Echo-back the input from a terminal 
 121               	************************************* 
 122               	
 123               	LOOP:
 124 007e 7001      	    move.l	#SYSCALL_NUM_GETSTRING, %d0
 125 0080 7200      	    move.l	#0, %d1			/*ch = 0*/
 126 0082 243C 0000 	    move.l	#BUF, %d2		/*p = #BUF*/
 126      0000 
 127 0088 263C 0000 	    move.l	#256, %d3		/*size = 256*/
 127      0100 
 128 008e 4E40      	    trap	#0
 129 0090 2600      	    move.l	%d0, %d3		/*size = %d0 (The length of a given string)*/
 130 0092 7002      	    move.l	#SYSCALL_NUM_PUTSTRING, %d0
 131 0094 7200      	    move.l	#0, %d1			/*ch = 0*/
 132 0096 243C 0000 	    move.l	#BUF, %d2		/*p = #BUF*/
 132      0000 
 133 009c 4E40      	    trap	#0
 134 009e 6000 FFDE 	    bra		LOOP		
 135               	
 136               	**************************************       
 137               	*    Test of the timer       
 138               	*    Display ‘******’ and CRLF (Carriage Return, Line Feed) five times       
 139               	*    Do RESET_TIMER after five times of the execution       
 140               	**************************************   
 141               	
 142               	TT:
 143 00a2 48E7 FFFE 	    movem.l	%d0-%d7/%a0-%a6, -(%sp)
 144 00a6 0C79 0005 	    cmpi.w	#5, TTC			/*Count with the counter TTC whether five times of the execution have been per
 144      0000 0000 
 145 00ae 6700 001C 	    beq		TTKILL			/*Stop the timer after five times of the execution*/
 146 00b2 7002      	    move.l	#SYSCALL_NUM_PUTSTRING, %d0
 147 00b4 7200      	    move.l	#0, %d1			/*ch = 0*/
 148 00b6 243C 0000 	    move.l	#TMSG, %d2		/*p = #TMSG*/
 148      0000 


 149 00bc 7608      	    move.l	#8, %d3			/*size = 8*/
 150 00be 4E40      	    trap	#0
 151 00c0 0679 0001 	    addi.w	#1, TTC			/*Increment TTC counter by 1 and return*/
 151      0000 0000 
 152 00c8 6000 0006 	    bra		TTEND
 153               	    
 154               	TTKILL:
 155 00cc 7003      	    move.l	#SYSCALL_NUM_RESET_TIMER, %d0
 156 00ce 4E40      	    trap	#0
 157               	    
 158               	TTEND:
 159 00d0 4CDF 7FFF 	    movem.l	(%sp)+, %d0-%d7/%a0-%a6
 160 00d4 4E75      	    rts
 161               	
 162               	****************************************************************
 163               	**  System Call Interface:
 164               	**     Maker: Morris Kim, Rafii Hakim
 165               	**  Reviewer: Lim Liang Sun, Napat Limsuwan
 166               	****************************************************************
 167               	        
 168               	SYSCALL:
 169 00d6 0C80 0000 		cmpi.l	#SYSCALL_NUM_GETSTRING, %d0
 169      0001 
 170 00dc 6700 0022 		beq	CALL_GETSTRING
 171 00e0 0C80 0000 		cmpi.l	#SYSCALL_NUM_PUTSTRING, %d0
 171      0002 
 172 00e6 6700 001E 		beq	CALL_PUTSTRING
 173 00ea 0C80 0000 		cmpi.l	#SYSCALL_NUM_RESET_TIMER, %d0
 173      0003 
 174 00f0 6700 001A 		beq	CALL_RESET_TIMER
 175 00f4 0C80 0000 		cmpi.l	#SYSCALL_NUM_SET_TIMER, %d0
 175      0004 
 176 00fa 6700 0016 		beq	CALL_SET_TIMER
 177 00fe 4E73      		rte
 178               		
 179               	CALL_GETSTRING:
 180 0100 4EBA 0156 		jsr	GETSTRING
 181 0104 4E73      		rte
 182               	CALL_PUTSTRING:
 183 0106 4EBA 0106 		jsr	PUTSTRING
 184 010a 4E73      		rte
 185               	CALL_RESET_TIMER:
 186 010c 4EBA 002A 		jsr	RESET_TIMER
 187 0110 4E73      		rte
 188               	CALL_SET_TIMER:
 189 0112 4EBA 002E 		jsr	SET_TIMER
 190 0116 4E73      		rte
 191               	
 192               	
 193               	****************************************************************
 194               	**  Timer interrupt
 195               	**     Maker: Lim Liang Sun, Napat Limsuwan
 196               	**  Reviewer: Morris Kim, Rafii Hakim
 197               	****************************************************************
 198               	TIMER_INTERRUPT:
 199 0118 48E7 0080 		movem.l	%a0, -(%sp)		/* Evacuate registers */
 200 011c 0C79 0000 		cmp	#0, TSTAT1		/* Checks 0th bit of TSTAT1 */


 200      00FF F60A 
 201 0124 6700 000C 		beq	TIMER_INTERRUPT_END
 202 0128 4279 00FF 		clr.w	TSTAT1			/* Reset TSTAT1 to 0 */
 202      F60A 
 203 012e 4EBA 0030 		jsr	CALL_RP
 204               	TIMER_INTERRUPT_END:
 205 0132 4CDF 0100 		movem.l	(%sp)+, %a0
 206 0136 4E73      		rte
 207               	
 208               	RESET_TIMER:
 209 0138 33FC 0004 		move.w 	#0x0004, TCTL1		/* Restart, an interrupt impossible, input is SYSCLK/16, prohibit timer */
 209      00FF F600 
 210 0140 4E75      		rts
 211               	SET_TIMER:
 212               		/* D1.W = t (timer interrupt cycle, every 0.t msec) */
 213               		/* D2.L = p (head address of the routine to be called at the interrupt occurrence) */
 214 0142 23C2 0000 		move.l	%d2, task_p		/* Substitute p for the global variable task_p*/
 214      0000 
 215 0148 33FC 00CE 		move.w	#0x00CE, TPRER1 	/* Let counter increment by 1 every 0.1 msec*/
 215      00FF F602 
 216 0150 33C1 00FF 		move.w	%d1, TCMP1		/* Substitute t for the TCMP1 */
 216      F604 
 217 0156 33FC 0015 		move.w	#0x0015, TCTL1		/* Restart, enable compare interrupt, input is SYSCLK/16, permit timer */
 217      00FF F600 
 218 015e 4E75      		rts
 219               	CALL_RP:
 220 0160 2079 0000 		move.l	(task_p), %a0
 220      0000 
 221 0166 4E90      		jsr	(%a0)
 222 0168 4E75      		rts
 223               	    
 224               	
 225               		
 226               	****************************************************************
 227               	**  UART1 Interrupt Interface
 228               	**     Maker: Morris Kim, Rafii Hakim
 229               	**  Reviewer: Lim Liang Sun, Napat Limsuwan
 230               	****************************************************************
 231               	INTERFACE:
 232 016a 48E7 F000 		movem.l	%d0-%d3,-(%sp)
 233               		
 234               		/* Receiver Interrupt */
 235 016e 3639 00FF 		move.w	URX1, %d3	/* Copy register URX1 to %d3.w*/
 235      F904 
 236 0174 0803 000D 		btst.l	#13, %d3 	/* Receiver FIFO? 1 = not empty, 0 = empty, yes it's confusing*/ 
 237 0178 6600 0020 		bne	CALL_INTERGET	/* Basically, this checks if it is a receiver interupt*/
 238               		
 239               		
 240               		/* Transmitter Interrupt */
 241 017c 3639 00FF 		move.w	UTX1, %d3
 241      F906 
 242 0182 0803 000F 		btst.l	#15, %d3	/* Transmitter FIFO empty? 1 = empty, 0 = not empty*/
 243 0186 6600 0008 		bne	CALL_INTERPUT	/* not equal to 1*/
 244               		
 245               		
 246               	INTERFACE_END:	
 247 018a 4CDF 000F 		movem.l	(%sp)+, %d0-%d3


 248 018e 4E73      		rte
 249               		
 250               	CALL_INTERPUT:
 251 0190 7200      		move.l	#0, %d1
 252 0192 4EBA 0036 		jsr	INTERPUT
 253 0196 6000 FFF2 		bra	INTERFACE_END
 254               	
 255               	CALL_INTERGET:
 256 019a 7200      		move.l	#0, %d1
 257 019c 1403      		move.b	%d3, %d2	/* Copy lower 8 bits (data part) of %d3.w to %d2.b*/
 258 019e 4EBA 0006 		jsr	INTERGET
 259 01a2 6000 FFE6 		bra	INTERFACE_END
 260               	
 261               	****************************************************************
 262               	**  INTERGET
 263               	**     Maker: Zelal Denis Yildiz
 264               	**  Reviewer: Amira Ben Youssef
 265               	****************************************************************	
 266               	INTERGET:
 267               		/* Input: Channel ch -> %d1, received data -> %d2 */
 268               		/* No return value */
 269 01a6 48E7 8000 		movem.l	%d0, -(%sp)
 270 01aa 0C81 0000 		cmpi.l	#0, %d1
 270      0000 
 271 01b0 6600 0012 		bne	INTERGET_END
 272 01b4 7000      		move.l	#0, %d0		/* Queue #0 */
 273 01b6 1202      		move.b	%d2, %d1 	/* move data to d1*/
 274 01b8 4EBA 010C 		jsr	INQ		
 275 01bc 13FC 0061 		move.b	#'a', LED0
 275      00D0 0039 
 276               		
 277               	INTERGET_END:
 278 01c4 4CDF 0001 		movem.l	(%sp)+, %d0
 279 01c8 4E75      		rts
 280               	        
 281               	****************************************************************
 282               	**  INTERPUT
 283               	**	Maker: Amira Ben Youssef
 284               	**  Reviewer: Zelal Denis Yildiz
 285               	****************************************************************	
 286               	INTERPUT:
 287               		/* Input: Channel ch -> %d1 */
 288               		/* d0 = UTX1 at the end, we need %d0 to compare when we return to INTERFACE*/
 289               		/* No return value */
 290               		
 291 01ca 48E7 2000 		movem.l	%d2,-(%sp)
 292 01ce 40C2      		move.w	%SR, %d2	/* Save running level */
 293 01d0 46FC 2700 		move.w	#0x2700, %SR	/* Set running level to 7 */
 294 01d4 0C81 0000 		cmp.l	#0, %d1		/* Return without doing anything if ch=/=0*/
 294      0000 
 295 01da 6600 002A 		bne	INTERPUT_END
 296 01de 7001      		move.l	#1, %d0		/* Queue #1 */
 297 01e0 4EBA 0112 		jsr	OUTQ		/* Substitute it for data?? */
 298               					/* d1 is data */
 299 01e4 0C80 0000 		cmp.l	#0, %d0 
 299      0000 
 300 01ea 6700 0012 		beq	MASK_TRANSMITTER_INTERRUPT


 301 01ee 0681 0000 		add.l	#0x0800, %d1
 301      0800 
 302 01f4 33C1 00FF 		move.w 	%d1, UTX1	/* Substitute the data for the transmitter register UTX1 */
 302      F906 
 303 01fa 6000 000A 		bra INTERPUT_END
 304               		
 305               	MASK_TRANSMITTER_INTERRUPT:
 306 01fe 0279 FFF8 		andi 	#0xfff8, USTCNT1 /* Mask the transmitter interrupt */
 306      00FF F900 
 307               		
 308               	INTERPUT_END:
 309 0206 46C2      		move.w	%d2, %SR	/* Restore running level */
 310 0208 4CDF 0004 		movem.l	(%sp)+, %d2
 311 020c 4E75      		rts
 312               	        
 313               	****************************************************************
 314               	**  PUTSTRING
 315               	**     Maker: Amira Ben Youssef
 316               	**  Reviewer: Zelal Denis Yildiz
 317               	****************************************************************
 318               	PUTSTRING:
 319               		/* Input: Channel ch -> d1, Head address p -> d2, No. of data -> d3 */
 320               		/* Output: no. of data actually sent -> d0 */
 321 020e 48E7 0880 		movem.l	%d4/%a0, -(%sp)
 322 0212 0C81 0000 		cmp.l	#0, %d1
 322      0000 
 323 0218 6600 0038 		bne	PUTSTRING_END	/* If ch =/= 0, end */
 324 021c 7800      		move.l	#0, %d4		/* d4 = sz */
 325 021e 2042      		move.l	%d2, %a0	/* a0 = i */
 326 0220 0C83 0000 		cmp.l	#0, %d3
 326      0000 
 327 0226 6700 0028 		beq	PUTSTRING_UPD_SZ
 328               		
 329               	PUTSTRING_LOOP:
 330 022a B684      		cmp.l	%d4, %d3	/* If sz == size */
 331 022c 6700 001A 		beq	PUTSTRING_UNMASK
 332 0230 1218      		move.b	(%a0)+, %d1	/* Put data in d1 */
 333 0232 7001      		move.l	#1, %d0		/* Use queue 1 */
 334 0234 4EBA 0090 		jsr	INQ
 335 0238 0C80 0000 		cmp.l	#0, %d0		/* If INQ failed*/
 335      0000 
 336 023e 6700 0008 		beq	PUTSTRING_UNMASK
 337 0242 5244      		addq	#1, %d4		/* Increment sz and i */
 338 0244 6000 FFE4 		bra	PUTSTRING_LOOP
 339               	
 340               	PUTSTRING_UNMASK:
 341 0248 0079 0007 		ori 	#0x0007, USTCNT1 	/* Permit the transmitter interrupt */
 341      00FF F900 
 342               	
 343               	PUTSTRING_UPD_SZ:	
 344 0250 2004      		move.l	%d4, %d0		/* %d0 <- sz */
 345               		
 346               	PUTSTRING_END:
 347 0252 4CDF 0110 		movem.l	(%sp)+, %d4/%a0
 348 0256 4E75      		rts
 349               	
 350               	****************************************************************


 351               	**  GETSTRING
 352               	**     Maker: Zelal Denis Yildiz
 353               	**  Reviewer: Amira Ben Youssef
 354               	****************************************************************
 355               	GETSTRING:
 356               		/* Input: ch -> d1, head address of destination p -> d2, no. of data to be read -> d3 */
 357               		/* Output: no. of data actually read out -> d0 */
 358 0258 48E7 0880 		movem.l	%d4/%a0, -(%sp)
 359 025c 0C81 0000 		cmpi.l	#0, %d1
 359      0000 
 360 0262 6600 0026 		bne	GETSTRING_END		/* If ch =/= 0, end */
 361 0266 7800      		move.l	#0, %d4			/* d4 = sz (Used to count no. of data actually read out) */
 362 0268 2042      		move.l	%d2, %a0		/* a0 = i (NOT Index, but head address of destination) */
 363               		
 364               	
 365               	GETSTRING_LOOP:
 366 026a B684      		cmp.l	%d4, %d3		/* is sz == size? */
 367 026c 6700 001A 		beq	GETSTRING_UPD_SZ
 368 0270 7000      		move.l	#0, %d0			/* specify queue 0 */
 369 0272 4EBA 0080 		jsr	OUTQ			/* Call OUTQ, puts data in d1 */
 370 0276 0C80 0000 		cmpi.l	#0, %d0			/* If failure */
 370      0000 
 371 027c 6700 000A 		beq	GETSTRING_UPD_SZ	/* End GETSTRING */
 372 0280 10C1      		move.b	%d1, (%a0)+		/* Copy the data to address i */
 373 0282 5244      		addq	#1, %d4			/* Increment sz and i */
 374 0284 4EFA FFE4 		jmp	GETSTRING_LOOP
 375               	
 376               	GETSTRING_UPD_SZ:	
 377 0288 2004      		move.l	%d4, %d0		/* %d0 <- sz */
 378               		
 379               	GETSTRING_END:
 380 028a 4CDF 0110 		movem.l	(%sp)+, %d4/%a0
 381 028e 4E75      		rts
 382               	
 383               	*****************************************************************
 384               	**  Queues
 385               	**     Maker: Amira Ben youssef, Zelal Denis Yildiz
 386               	**  Reviewer: Moris Kim
 387               	*****************************************************************
 388               	INIT_Q:
 389 0290 48E7 0078 		movem.l	%a1-%a4, -(%sp)
 390               	  
 391 0294 43F9 0000 		lea.l	top, %a1		/*top address is a1*/
 391      0000 
 392 029a 45F9 0000 		lea.l  	inp, %a2
 392      0000 
 393 02a0 47F9 0000 		lea.l  	outp, %a3
 393      0000 
 394 02a6 49F9 0000 		lea.l  	s, %a4
 394      0000 
 395 02ac 24C9      		move.l	%a1, (%a2)+ 		/* Initialize inp, outp, and s for q0*/
 396 02ae 26C9      		move.l	%a1, (%a3)+
 397 02b0 38FC 0000 		move.w	#0, (%a4)+
 398 02b4 D2FC 0100 		adda  	#SIZE_of_QUEUE, %a1 	/* add offset for q1 */
 399 02b8 2489      		move.l	%a1, (%a2)  		/* Initialize inp, outp, and s for q1*/
 400 02ba 2689      		move.l	%a1, (%a3)
 401 02bc 38BC 0000 		move.w	#0, (%a4)


 402 02c0 4CDF 1E00 		movem.l	(%sp)+, %a1-%a4
 403 02c4 4E75      		rts
 404               	
 405               	INQ:
 406               		/* Input: Queue no. -> %d0, Data -> %d1 */
 407               		/* Output: Success/fail -> %d0 */
 408 02c6 48E7 3C7C 		movem.l	%d2-%d5/%a1-%a5,-(%sp)    /* Save registers */
 409 02ca 4EBA 0058 		jsr	Q_START
 410 02ce 45F9 0000 		lea.l 	inp, %a2		  /* inp -> a2 */
 410      0000 
 411 02d4 D5C2      		adda.l  %d2, %a2  		  /* add offset */
 412 02d6 2252      		move.l  (%a2), %a1 		  /* a1 = in pointer */
 413 02d8 4EBA 0006 		jsr	INQ_SIZE_CHECK
 414 02dc 4EFA 0090 		jmp 	Q_FINISH
 415               	
 416               	INQ_SIZE_CHECK:
 417 02e0 0C53 0100 		cmp.w	#256, (%a3)  		 /* check if queue is full */
 418 02e4 6600 0006 		bne	INQ_SUCC	         /* if s not equals to 256 */
 419 02e8 6000 0080 		bra	Q_FAIL		 	 /* if s==256 */
 420               	
 421               	INQ_SUCC:
 422 02ec 1281      		move.b 	%d1, (%a1) 		 /* d1 = data moved into inp */
 423 02ee 5253      		addq    #1, (%a3)   		 /* Increment size */
 424 02f0 4EFA 004E 		jmp     Q_SUCC
 425               	
 426               	OUTQ:
 427               		/* Input: Queue no. -> %d0 */
 428               		/* Output: Success/fail -> %d0, Data -> %d1 */
 429 02f4 48E7 3C7C 		movem.l	%d2-%d5/%a1-%a5,-(%sp)   /* Save registers */
 430 02f8 4EBA 002A 		jsr     Q_START
 431 02fc 45F9 0000 		lea.l 	outp, %a2	         /* outp -> a2 */
 431      0000 
 432 0302 D5C2      		adda.l  %d2, %a2   		 /* add offset */
 433 0304 2252      		move.l  (%a2), %a1  		 /* a1 = out pointer */
 434               	
 435 0306 4EBA 0006 		jsr	OUTQ_SIZE_CHECK
 436 030a 4EFA 0062 		jmp 	Q_FINISH
 437               	
 438               	OUTQ_SIZE_CHECK:
 439 030e 0C53 0000 		cmp.w 	#0, (%a3)   		 /* check if queue is empty*/
 440 0312 6E00 0006 		bgt 	OUTQ_SUCC
 441 0316 6000 0052 		bra	Q_FAIL
 442               	
 443               	OUTQ_SUCC:
 444 031a 1211      		move.b	(%a1), %d1 		/* data is moved to d1*/
 445 031c 0453 0001 		subi.w  #1, (%a3)    		/* Decrement size */
 446               	
 447 0320 4EFA 001E 		jmp 	Q_SUCC
 448               	  
 449               	
 450               	/* These are common for both INQ and OUTQ */
 451               	Q_START:
 452 0324 40C5      		move.w	%SR, %d5   	 /* Save running level */
 453 0326 46FC 2700 		move.w 	#0x2700, %SR	 /* running level = 7 */
 454 032a 2400      		move.l 	%d0, %d2  	 /* d2 = pointer offset */
 455 032c C4FC 0004 		mulu	#4,  %d2  	 /* because address is stored in longword */
 456 0330 2600      		move.l  %d0, %d3  	 /* d3 = queue size pointer offset */


 457 0332 C6FC 0002 		mulu	#2, %d3	  	 /* because address is stored in word */
 458 0336 47F9 0000 		lea.l	s,   %a3  	 /* size -> a3 */
 458      0000 
 459 033c D7C3      		adda.l  %d3, %a3   	 /* add offset */
 460 033e 4E75      		rts
 461               	
 462               	Q_SUCC:
 463 0340 2800      		move.l 	%d0, %d4  	 /* d4 = queue area offset */
 464 0342 C8FC 0100 		mulu	#SIZE_of_QUEUE, %d4
 465 0346 49F9 0000 		lea.l   top, %a4 	 /* a4 = head of queue area */
 465      0000 
 466 034c D9C4      		adda.l  %d4, %a4  	 /* adds offset */
 467 034e 2A4C      		move.l  %a4, %a5  	 /* a5 = bottom of queue area */
 468 0350 DBFC 0000 		adda.l  #255, %a5 	 /* the bottom is 255 from the top */
 468      00FF 
 469 0356 7001      		move.l  #1, %d0    	 /* success flag raised */
 470 0358 BAC9      		cmp	%a1, %a5	 /* compare inp/outp with bottom*/
 471 035a 6700 000A 		beq	Q_BACK		 /* reach the bottom */
 472 035e 6000 0002 		bra	Q_NEXT
 473               	
 474               	Q_NEXT:
 475 0362 5249      		addq	#1, %a1   	 /* increment input/output pointer*/
 476 0364 4E75      		rts
 477               	
 478               	Q_BACK:
 479 0366 224C      		move.l	%a4, %a1         /* input/output pointer set to head of queue area */
 480 0368 4E75      		rts	
 481               	
 482               	Q_FAIL:
 483 036a 7000      		move.l	#0, %d0   	 /* set flag to fail */
 484 036c 4E75      		rts
 485               	
 486               	Q_FINISH:
 487 036e 2489      		move.l	%a1, (%a2)   	 /* update inp/outp */
 488 0370 46C5      		move.w	%d5, %SR     	 /* restore previous running level */
 489 0372 4CDF 3E3C 		movem.l	(%sp)+,%d2-%d5/%a1-%a5  /* restore registers */
 490 0376 4E75      		rts
 491               	
 492               	.section .data
 493               	    .equ	SIZE_of_QUEUE,	256
 494               	
 495               	.section .bss
 496               	.even
 497 4000 0000 0000 	top:		.ds.b	SIZE_of_QUEUE*2
 497      0000 0000 
 497      0000 0000 
 497      0000 0000 
 497      0000 0000 
 498 4200 0000 0000 	inp:		.ds.l	2
 498      0000 0000 
 499 4208 0000 0000 	outp:		.ds.l	2
 499      0000 0000 
 500 4210 0000 0000 	s:		.ds.w	2
 501 4214 0000 0000 	task_p:		.ds.l	1
 502               	
 503               	            .even
 504               	


 505               	****************************************************************
 506               	**	Data region with an initial value
 507               	****************************************************************
 508               	.section .data
 509 0000 2A2A 2A2A 	TMSG:		.ascii	"******\r\n"
 509      2A2A 0D0A 
 510               	            .even
 511 0008 0000      	TTC:		.dc.w	0
 512               	            .even
 513               	
 514               	****************************************************************
 515               	**	Data region without an initial value
 516               	****************************************************************
 517               	.section .bss
 518 4218 0000 0000 	BUF:		.ds.b	256
 518      0000 0000 
 518      0000 0000 
 518      0000 0000 
 518      0000 0000 
 519               	            .even
 520               	USR_STK:
 521 4318 0000 0000 	            .ds.b	0x4000
 521      0000 0000 
 521      0000 0000 
 521      0000 0000 
 521      0000 0000 
 522               	            .even
 523               	USR_STK_TOP:




   1               	/*
   2               	.global inbyte                  | Export inbyte function to other files
   3               	
   4               	.text
   5               	.even
   6               	
   7               	inbyte:
   8               	    movem.l %d1-%d3, -(%sp)     | Save registers that will be used
   9               	inbyte_start:
  10               	    move.l	#1, %d0             | System call number for GETSTRING
  11               	    move.l	#0, %d1			    | Serial port number = 0
  12               	    move.l	#BUF_INBYTE, %d2    | Buffer address
  13               	    move.l	#1, %d3             | Buffer size = 1 byte
  14               	    trap	#0                  | Initiate system call to GETSTRING
  15               	
  16               	    cmpi.b	#1, %d0             | Check if GETSTRING was successful (1 byte read)
  17               	    bne     inbyte_start        | If not, try again
  18               	
  19               	    clr.l	%d0
  20               	    move.b  BUF_INBYTE, %d0     | Move byte from buffer to %d0
  21               	
  22               	    movem.l (%sp)+, %d1-%d3     | Restore registers
  23               	    rts                         | Return from function
  24               	
  25               	.section .bss
  26               	BUF_INBYTE: .ds.b 1             | 1 byte buffer for inbyte function
  27               	    .even
  28               	*/
  29               	
  30               	.global inbyte                  | Export inbyte function to other files
  31               	
  32               	.text
  33               	.even
  34               	
  35               	inbyte:
  36 0000 48E7 7000 	    movem.l %d1-%d3, -(%sp)     | Save registers %d1, %d2, %d3
  37               	inbyte_loop:
  38 0004 7001      	    move.l	#1, %d0             | System call number for GETSTRING
  39 0006 7200      	    move.l	#0, %d1             | Serial port number = 0
  40 0008 41F9 0000 	    lea	    	inbyte_buffer, %a0  | Load buffer address into %a0
  40      0000 
  41 000e 2408      	    move.l	%a0, %d2            | Pass buffer address to %d2
  42 0010 7601      	    move.l	#1, %d3             | Buffer size = 1 byte
  43 0012 4E40      	    trap	#0                  | Initiate system call to GETSTRING
  44               	
  45 0014 4A00      	    tst.b   %d0                 | Check if 1 byte was successfully read
  46 0016 6700 FFEC 	    beq     inbyte_loop         | Retry if no byte was read (result is zero)
  47               	
  48 001a 1039 0000 	    move.b  inbyte_buffer, %d0     | Load byte from buffer into %d0
  48      0000 
  49 0020 4CDF 000E 	    movem.l (%sp)+, %d1-%d3     | Restore saved registers
  50 0024 4E75      	    rts                         | Return from function
  51               	
  52               	.section .bss
  53 0000 00        	inbyte_buffer: .ds.b 1             | 1 byte buffer for inbyte function
  54 0001 00        	.even
  55               	






   1               	/*
   2               	.global outbyte                 | Export inbyte function to other files
   3               	
   4               	.text
   5               	.even
   6               	
   7               	outbyte:
   8               	    ** First argument (long word size) from C program is offset 4 from the top of the stack **
   9               	    ** to get the byte size argument, we need to offset 3 more bytes from the beginning of the firs
  10               	    ** so 7 is added to the stack pointer to get the byte sized argument sent from the C program **
  11               	    move.b  7(%sp), BUF_OUTBYTE | Get outbyte argument from stack
  12               	    movem.l %d0-%d3, -(%sp)     | Save registers that will be used
  13               	outbyte_start:
  14               	    move.l	#2, %d0             | System call number for PUTSTRING
  15               	    move.l	#0, %d1             | Serial port number = 0
  16               	    move.l	#BUF_OUTBYTE, %d2   | Buffer address
  17               	    move.l	#1, %d3             | Buffer size = 1 byte
  18               	    trap	#0                  | Initiate system call to PUTSTRING
  19               	
  20               	    cmpi.b	#1, %d0             | Check if PUTSTRING was successful (1 byte read)
  21               	    bne     outbyte_start       | If not, try again
  22               	
  23               	    movem.l (%sp)+, %d0-%d3     | Restore registers
  24               	    rts                         | Return from function
  25               	
  26               	.section .bss
  27               	BUF_OUTBYTE:    .ds.b 1         | 1 byte Buffer for outbyte function
  28               	    .even
  29               	*/
  30               	    
  31               	.global outbyte                 | Export outbyte function to other files
  32               	
  33               	.text
  34               	.even
  35               	
  36               	outbyte:
  37               	    ** First argument (long word size) from C program is offset 4 from the top of the stack **
  38               	    ** to get the byte size argument, we need to offset 3 more bytes from the beginning of the firs
  39               	    ** so 7 is added to the stack pointer to get the byte sized argument sent from the C program **
  40 0000 13EF 0007 	    move.b  7(%sp), outbyte_buffer | Get outbyte argument from stack
  40      0000 0000 
  41 0008 48E7 F000 	    movem.l %d0-%d3, -(%sp)     | Save registers that will be used
  42               	outbyte_loop:
  43 000c 7002      	    move.l	#2, %d0             | System call number for PUTSTRING
  44 000e 7200      	    move.l	#0, %d1             | Serial port number = 0
  45 0010 41F9 0000 	    lea     outbyte_buffer, %a0 | Load buffer address into %a0
  45      0000 
  46 0016 2408      	    move.l	%a0, %d2            | Pass buffer address to %d2
  47 0018 7601      	    move.l	#1, %d3             | Buffer size = 1 byte
  48 001a 4E40      	    trap	#0                  | Initiate system call to PUTSTRING
  49               	
  50 001c 4A00      	    tst.b   %d0                 | Check if PUTSTRING was successful (1 byte read)
  51 001e 6700 FFEC 	    beq     outbyte_loop        | Retry if not successful
  52               	
  53 0022 4CDF 000F 	    movem.l (%sp)+, %d0-%d3     | Restore registers
  54 0026 4E75      	    rts                         | Return from function
  55               	


  56               	.section .bss
  57 0000 00        	outbyte_buffer:    .ds.b 1         | 1-byte buffer for outbyte function
  58 0001 00        	.even
  59               	   
  60               	    
  61               	    




   1               	#NO_APP
   2               		.file	"csys68k.c"
   3               		.text
   4               	.Ltext0:
   5               		.cfi_sections	.debug_frame
   6               		.align	2
   7               		.globl	read
   8               		.type	read, @function
   9               	read:
  10               	.LVL0:
  11               	.LFB0:
  12               		.file 1 "csys68k.c"
   1:csys68k.c     **** extern void outbyte(unsigned char c);
   2:csys68k.c     **** extern char inbyte();
   3:csys68k.c     **** 
   4:csys68k.c     **** int read(int fd, char *buf, int nbytes)
   5:csys68k.c     **** {
  13               		.loc 1 5 1 view -0
  14               		.cfi_startproc
  15               		.loc 1 5 1 is_stmt 0 view .LVU1
  16 0000 48E7 3838 		movem.l #14392,-(%sp)
  17               		.cfi_def_cfa_offset 28
  18               		.cfi_offset 2, -28
  19               		.cfi_offset 3, -24
  20               		.cfi_offset 4, -20
  21               		.cfi_offset 10, -16
  22               		.cfi_offset 11, -12
  23               		.cfi_offset 12, -8
  24 0004 286F 0020 		move.l 32(%sp),%a4
  25 0008 282F 0024 		move.l 36(%sp),%d4
   6:csys68k.c     ****   char c;
  26               		.loc 1 6 3 is_stmt 1 view .LVU2
   7:csys68k.c     ****   int  i;
  27               		.loc 1 7 3 view .LVU3
   8:csys68k.c     **** 
   9:csys68k.c     ****   for (i = 0; i < nbytes; i++) {
  28               		.loc 1 9 3 view .LVU4
  29               	.LVL1:
  30               		.loc 1 9 17 view .LVU5
  31               		.loc 1 9 10 is_stmt 0 view .LVU6
  32 000c 7600      		moveq #0,%d3
  33               		.loc 1 9 17 view .LVU7
  34 000e 4A84      		tst.l %d4
  35 0010 6F36      		jle .L1
  36 0012 47F9 0000 		lea inbyte,%a3
  36      0000 
  37 0018 45F9 0000 		lea outbyte,%a2
  37      0000 
  38               	.LVL2:
  39               	.L8:
  10:csys68k.c     ****     c = inbyte();
  40               		.loc 1 10 5 is_stmt 1 view .LVU8
  41               		.loc 1 10 9 is_stmt 0 view .LVU9
  42 001e 4E93      		jsr (%a3)
  43               	.LVL3:
  44 0020 1400      		move.b %d0,%d2
  45               	.LVL4:


  11:csys68k.c     **** 
  12:csys68k.c     ****     if (c == '\r' || c == '\n'){ /* CR -> CRLF */
  46               		.loc 1 12 5 is_stmt 1 view .LVU10
  47               		.loc 1 12 8 is_stmt 0 view .LVU11
  48 0022 0C00 000D 		cmp.b #13,%d0
  49 0026 6728      		jeq .L3
  50               		.loc 1 12 19 discriminator 1 view .LVU12
  51 0028 0C00 000A 		cmp.b #10,%d0
  52 002c 6722      		jeq .L3
  13:csys68k.c     ****       outbyte('\r');
  14:csys68k.c     ****       outbyte('\n');
  15:csys68k.c     ****       *(buf + i) = '\n';
  16:csys68k.c     **** 
  17:csys68k.c     ****     /* } else if (c == '\x8'){ */     /* backspace \x8 */
  18:csys68k.c     ****     } else if (c == '\x7f'){      /* backspace \x8 -> \x7f (by terminal config.) */
  53               		.loc 1 18 12 is_stmt 1 view .LVU13
  54               		.loc 1 18 15 is_stmt 0 view .LVU14
  55 002e 0C00 007F 		cmp.b #127,%d0
  56 0032 673A      		jeq .L18
  19:csys68k.c     ****       if (i > 0){
  20:csys68k.c     **** 	outbyte('\x8'); /* bs  */
  21:csys68k.c     **** 	outbyte(' ');   /* spc */
  22:csys68k.c     **** 	outbyte('\x8'); /* bs  */
  23:csys68k.c     **** 	i--;
  24:csys68k.c     ****       }
  25:csys68k.c     ****       i--;
  26:csys68k.c     ****       continue;
  27:csys68k.c     **** 
  28:csys68k.c     ****     } else {
  29:csys68k.c     ****       outbyte(c);
  57               		.loc 1 29 7 is_stmt 1 view .LVU15
  58 0034 7000      		moveq #0,%d0
  59               	.LVL5:
  60               		.loc 1 29 7 is_stmt 0 view .LVU16
  61 0036 1002      		move.b %d2,%d0
  62 0038 2F00      		move.l %d0,-(%sp)
  63               		.cfi_def_cfa_offset 32
  64 003a 4E92      		jsr (%a2)
  65               	.LVL6:
  30:csys68k.c     ****       *(buf + i) = c;
  66               		.loc 1 30 7 is_stmt 1 view .LVU17
  67               		.loc 1 30 18 is_stmt 0 view .LVU18
  68 003c 1982 3800 		move.b %d2,(%a4,%d3.l)
  31:csys68k.c     ****     }
  32:csys68k.c     **** 
  33:csys68k.c     ****     if (*(buf + i) == '\n'){
  69               		.loc 1 33 5 is_stmt 1 view .LVU19
  34:csys68k.c     ****       return (i + 1);
  70               		.loc 1 34 17 is_stmt 0 view .LVU20
  71 0040 5283      		addq.l #1,%d3
  72               	.LVL7:
  73               		.loc 1 34 17 view .LVU21
  74 0042 588F      		addq.l #4,%sp
  75               		.cfi_def_cfa_offset 28
  76               	.LVL8:
   9:csys68k.c     ****     c = inbyte();
  77               		.loc 1 9 28 is_stmt 1 view .LVU22


   9:csys68k.c     ****     c = inbyte();
  78               		.loc 1 9 17 view .LVU23
  79 0044 B684      		cmp.l %d4,%d3
  80 0046 6DD6      		jlt .L8
  81               	.LVL9:
  82               	.L1:
  35:csys68k.c     ****     }
  36:csys68k.c     ****   }
  37:csys68k.c     ****   return (i);
  38:csys68k.c     **** }
  83               		.loc 1 38 1 is_stmt 0 view .LVU24
  84 0048 2003      		move.l %d3,%d0
  85 004a 4CDF 1C1C 		movem.l (%sp)+,#7196
  86 004e 4E75      		rts
  87               	.LVL10:
  88               	.L3:
  13:csys68k.c     ****       outbyte('\n');
  89               		.loc 1 13 7 is_stmt 1 view .LVU25
  90 0050 4878 000D 		pea 13.w
  91               		.cfi_def_cfa_offset 32
  92 0054 4E92      		jsr (%a2)
  93               	.LVL11:
  14:csys68k.c     ****       *(buf + i) = '\n';
  94               		.loc 1 14 7 view .LVU26
  95 0056 4878 000A 		pea 10.w
  96               		.cfi_def_cfa_offset 36
  97 005a 4E92      		jsr (%a2)
  98               	.LVL12:
  15:csys68k.c     **** 
  99               		.loc 1 15 7 view .LVU27
  15:csys68k.c     **** 
 100               		.loc 1 15 18 is_stmt 0 view .LVU28
 101 005c 19BC 000A 		move.b #10,(%a4,%d3.l)
 101      3800 
  33:csys68k.c     ****       return (i + 1);
 102               		.loc 1 33 5 is_stmt 1 view .LVU29
  34:csys68k.c     ****     }
 103               		.loc 1 34 7 view .LVU30
  34:csys68k.c     ****     }
 104               		.loc 1 34 17 is_stmt 0 view .LVU31
 105 0062 5283      		addq.l #1,%d3
 106               	.LVL13:
  34:csys68k.c     ****     }
 107               		.loc 1 34 17 view .LVU32
 108 0064 508F      		addq.l #8,%sp
 109               		.cfi_def_cfa_offset 28
 110               		.loc 1 38 1 view .LVU33
 111 0066 2003      		move.l %d3,%d0
 112 0068 4CDF 1C1C 		movem.l (%sp)+,#7196
 113               	.LVL14:
 114               		.loc 1 38 1 view .LVU34
 115 006c 4E75      		rts
 116               	.LVL15:
 117               	.L18:
  19:csys68k.c     **** 	outbyte('\x8'); /* bs  */
 118               		.loc 1 19 7 is_stmt 1 view .LVU35
  19:csys68k.c     **** 	outbyte('\x8'); /* bs  */


 119               		.loc 1 19 10 is_stmt 0 view .LVU36
 120 006e 4A83      		tst.l %d3
 121 0070 67AC      		jeq .L8
  23:csys68k.c     ****       }
 122               		.loc 1 23 3 view .LVU37
 123 0072 5383      		subq.l #1,%d3
 124               	.LVL16:
  20:csys68k.c     **** 	outbyte(' ');   /* spc */
 125               		.loc 1 20 2 is_stmt 1 view .LVU38
 126 0074 4878 0008 		pea 8.w
 127               		.cfi_def_cfa_offset 32
 128 0078 4E92      		jsr (%a2)
 129               	.LVL17:
  21:csys68k.c     **** 	outbyte('\x8'); /* bs  */
 130               		.loc 1 21 2 view .LVU39
 131 007a 4878 0020 		pea 32.w
 132               		.cfi_def_cfa_offset 36
 133 007e 4E92      		jsr (%a2)
 134               	.LVL18:
  22:csys68k.c     **** 	i--;
 135               		.loc 1 22 2 view .LVU40
 136 0080 4878 0008 		pea 8.w
 137               		.cfi_def_cfa_offset 40
 138 0084 4E92      		jsr (%a2)
 139               	.LVL19:
  23:csys68k.c     ****       }
 140               		.loc 1 23 2 view .LVU41
  25:csys68k.c     ****       continue;
 141               		.loc 1 25 7 view .LVU42
  26:csys68k.c     **** 
 142               		.loc 1 26 7 view .LVU43
 143 0086 4FEF 000C 		lea (12,%sp),%sp
 144               		.cfi_def_cfa_offset 28
 145               	.LVL20:
   9:csys68k.c     ****     c = inbyte();
 146               		.loc 1 9 28 view .LVU44
   9:csys68k.c     ****     c = inbyte();
 147               		.loc 1 9 17 view .LVU45
 148 008a B684      		cmp.l %d4,%d3
 149 008c 6D90      		jlt .L8
 150 008e 60B8      		jra .L1
 151               		.cfi_endproc
 152               	.LFE0:
 153               		.size	read, .-read
 154               		.align	2
 155               		.globl	write
 156               		.type	write, @function
 157               	write:
 158               	.LVL21:
 159               	.LFB1:
  39:csys68k.c     **** 
  40:csys68k.c     **** int write (int fd, char *buf, int nbytes)
  41:csys68k.c     **** {
 160               		.loc 1 41 1 view -0
 161               		.cfi_startproc
 162               		.loc 1 41 1 is_stmt 0 view .LVU47
 163 0090 48E7 3030 		movem.l #12336,-(%sp)


 164               		.cfi_def_cfa_offset 20
 165               		.cfi_offset 2, -20
 166               		.cfi_offset 3, -16
 167               		.cfi_offset 10, -12
 168               		.cfi_offset 11, -8
 169 0094 262F 001C 		move.l 28(%sp),%d3
  42:csys68k.c     ****   int i, j;
 170               		.loc 1 42 3 is_stmt 1 view .LVU48
  43:csys68k.c     ****   for (i = 0; i < nbytes; i++) {
 171               		.loc 1 43 3 view .LVU49
 172               	.LVL22:
 173               		.loc 1 43 17 view .LVU50
 174 0098 6F26      		jle .L25
 175 009a 246F 0018 		move.l 24(%sp),%a2
 176 009e 240A      		move.l %a2,%d2
 177 00a0 D483      		add.l %d3,%d2
 178 00a2 47F9 0000 		lea outbyte,%a3
 178      0000 
 179               	.LVL23:
 180               	.L22:
  44:csys68k.c     ****     if (*(buf + i) == '\n') {
 181               		.loc 1 44 5 view .LVU51
 182               		.loc 1 44 9 is_stmt 0 view .LVU52
 183 00a8 101A      		move.b (%a2)+,%d0
 184               	.LVL24:
 185               		.loc 1 44 8 view .LVU53
 186 00aa 0C00 000A 		cmp.b #10,%d0
 187 00ae 6718      		jeq .L28
  45:csys68k.c     ****       outbyte ('\r');          /* LF -> CRLF */
  46:csys68k.c     ****     }
  47:csys68k.c     ****     outbyte (*(buf + i));
 188               		.loc 1 47 5 is_stmt 1 view .LVU54
 189 00b0 0280 0000 		and.l #255,%d0
 189      00FF 
 190 00b6 2F00      		move.l %d0,-(%sp)
 191               		.cfi_def_cfa_offset 24
 192 00b8 4E93      		jsr (%a3)
 193               	.LVL25:
  48:csys68k.c     ****     for (j = 0; j < 300; j++);
 194               		.loc 1 48 5 view .LVU55
 195               		.loc 1 48 19 view .LVU56
  43:csys68k.c     ****     if (*(buf + i) == '\n') {
 196               		.loc 1 43 28 view .LVU57
  43:csys68k.c     ****     if (*(buf + i) == '\n') {
 197               		.loc 1 43 17 view .LVU58
 198 00ba 588F      		addq.l #4,%sp
 199               		.cfi_def_cfa_offset 20
 200 00bc B48A      		cmp.l %a2,%d2
 201 00be 66E8      		jne .L22
 202               	.LVL26:
 203               	.L25:
  49:csys68k.c     ****   }
  50:csys68k.c     ****   return (nbytes);
  51:csys68k.c     **** }
 204               		.loc 1 51 1 is_stmt 0 view .LVU59
 205 00c0 2003      		move.l %d3,%d0
 206 00c2 4CDF 0C0C 		movem.l (%sp)+,#3084


 207 00c6 4E75      		rts
 208               	.LVL27:
 209               	.L28:
  45:csys68k.c     ****     }
 210               		.loc 1 45 7 is_stmt 1 view .LVU60
 211 00c8 4878 000D 		pea 13.w
 212               		.cfi_def_cfa_offset 24
 213 00cc 4E93      		jsr (%a3)
 214               	.LVL28:
  47:csys68k.c     ****     for (j = 0; j < 300; j++);
 215               		.loc 1 47 14 is_stmt 0 view .LVU61
 216 00ce 102A FFFF 		move.b -1(%a2),%d0
 217 00d2 588F      		addq.l #4,%sp
 218               		.cfi_def_cfa_offset 20
  47:csys68k.c     ****     for (j = 0; j < 300; j++);
 219               		.loc 1 47 5 is_stmt 1 view .LVU62
 220 00d4 0280 0000 		and.l #255,%d0
 220      00FF 
 221 00da 2F00      		move.l %d0,-(%sp)
 222               		.cfi_def_cfa_offset 24
 223 00dc 4E93      		jsr (%a3)
 224               	.LVL29:
  48:csys68k.c     ****   }
 225               		.loc 1 48 5 view .LVU63
  48:csys68k.c     ****   }
 226               		.loc 1 48 19 view .LVU64
  43:csys68k.c     ****     if (*(buf + i) == '\n') {
 227               		.loc 1 43 28 view .LVU65
  43:csys68k.c     ****     if (*(buf + i) == '\n') {
 228               		.loc 1 43 17 view .LVU66
 229 00de 588F      		addq.l #4,%sp
 230               		.cfi_def_cfa_offset 20
 231 00e0 B48A      		cmp.l %a2,%d2
 232 00e2 66C4      		jne .L22
 233 00e4 60DA      		jra .L25
 234               		.cfi_endproc
 235               	.LFE1:
 236               		.size	write, .-write
 237               	.Letext0:
 238               		.section	.debug_info,"",@progbits
 239               	.Ldebug_info0:
 240 0000 0000 017B 		.long	0x17b
 241 0004 0005      		.word	0x5
 242 0006 01        		.byte	0x1
 243 0007 04        		.byte	0x4
 244 0008 0000 0000 		.long	.Ldebug_abbrev0
 245 000c 06        		.uleb128 0x6
 246 000d 0000 0000 		.long	.LASF5
 247 0011 1D        		.byte	0x1d
 248 0012 0000 0000 		.long	.LASF6
 249 0016 0000 0000 		.long	.LASF7
 250 001a 0000 0000 		.long	.Ltext0
 251 001e 0000 00E6 		.long	.Letext0-.Ltext0
 252 0022 0000 0000 		.long	.Ldebug_line0
 253 0026 07        		.uleb128 0x7
 254 0027 0000 0000 		.long	.LASF0
 255 002b 01        		.byte	0x1


 256 002c 01        		.byte	0x1
 257 002d 0D        		.byte	0xd
 258 002e 0000 0038 		.long	0x38
 259 0032 08        		.uleb128 0x8
 260 0033 0000 0038 		.long	0x38
 261 0037 00        		.byte	0
 262 0038 04        		.uleb128 0x4
 263 0039 08        		.byte	0x8
 264 003a 0000 0000 		.long	.LASF2
 265 003e 09        		.uleb128 0x9
 266 003f 0000 0000 		.long	.LASF1
 267 0043 01        		.byte	0x1
 268 0044 02        		.byte	0x2
 269 0045 0D        		.byte	0xd
 270 0046 0000 0050 		.long	0x50
 271 004a 0000 0050 		.long	0x50
 272 004e 0A        		.uleb128 0xa
 273 004f 00        		.byte	0
 274 0050 04        		.uleb128 0x4
 275 0051 06        		.byte	0x6
 276 0052 0000 0000 		.long	.LASF3
 277 0056 0B        		.uleb128 0xb
 278 0057 0000 0000 		.long	.LASF8
 279 005b 01        		.byte	0x1
 280 005c 28        		.byte	0x28
 281 005d 05        		.byte	0x5
 282 005e 0000 00D0 		.long	0xd0
 283 0062 0000 0000 		.long	.LFB1
 284 0066 0000 0056 		.long	.LFE1-.LFB1
 285 006a 01        		.uleb128 0x1
 286 006b 9C        		.byte	0x9c
 287 006c 0000 00D0 		.long	0xd0
 288 0070 02        		.uleb128 0x2
 289 0071 6664 00   		.string	"fd"
 290 0074 28        		.byte	0x28
 291 0075 10        		.byte	0x10
 292 0076 0000 00D0 		.long	0xd0
 293 007a 02        		.uleb128 0x2
 294 007b 91        		.byte	0x91
 295 007c 00        		.sleb128 0
 296 007d 02        		.uleb128 0x2
 297 007e 6275 6600 		.string	"buf"
 298 0082 28        		.byte	0x28
 299 0083 1A        		.byte	0x1a
 300 0084 0000 00D7 		.long	0xd7
 301 0088 02        		.uleb128 0x2
 302 0089 91        		.byte	0x91
 303 008a 04        		.sleb128 4
 304 008b 05        		.uleb128 0x5
 305 008c 0000 0000 		.long	.LASF4
 306 0090 28        		.byte	0x28
 307 0091 23        		.byte	0x23
 308 0092 0000 00D0 		.long	0xd0
 309 0096 02        		.uleb128 0x2
 310 0097 91        		.byte	0x91
 311 0098 08        		.sleb128 8
 312 0099 03        		.uleb128 0x3


 313 009a 6900      		.string	"i"
 314 009c 2A        		.byte	0x2a
 315 009d 07        		.byte	0x7
 316 009e 0000 00D0 		.long	0xd0
 317 00a2 0000 0000 		.long	.LLST2
 318 00a6 0000 0000 		.long	.LVUS2
 319 00aa 0C        		.uleb128 0xc
 320 00ab 6A00      		.string	"j"
 321 00ad 01        		.byte	0x1
 322 00ae 2A        		.byte	0x2a
 323 00af 0A        		.byte	0xa
 324 00b0 0000 00D0 		.long	0xd0
 325 00b4 01        		.uleb128 0x1
 326 00b5 0000 0000 		.long	.LVL25
 327 00b9 0000 0026 		.long	0x26
 328 00bd 01        		.uleb128 0x1
 329 00be 0000 0000 		.long	.LVL28
 330 00c2 0000 0026 		.long	0x26
 331 00c6 01        		.uleb128 0x1
 332 00c7 0000 0000 		.long	.LVL29
 333 00cb 0000 0026 		.long	0x26
 334 00cf 00        		.byte	0
 335 00d0 0D        		.uleb128 0xd
 336 00d1 04        		.byte	0x4
 337 00d2 05        		.byte	0x5
 338 00d3 696E 7400 		.string	"int"
 339 00d7 0E        		.uleb128 0xe
 340 00d8 04        		.byte	0x4
 341 00d9 0000 0050 		.long	0x50
 342 00dd 0F        		.uleb128 0xf
 343 00de 0000 0000 		.long	.LASF9
 344 00e2 01        		.byte	0x1
 345 00e3 04        		.byte	0x4
 346 00e4 05        		.byte	0x5
 347 00e5 0000 00D0 		.long	0xd0
 348 00e9 0000 0000 		.long	.LFB0
 349 00ed 0000 0090 		.long	.LFE0-.LFB0
 350 00f1 01        		.uleb128 0x1
 351 00f2 9C        		.byte	0x9c
 352 00f3 02        		.uleb128 0x2
 353 00f4 6664 00   		.string	"fd"
 354 00f7 04        		.byte	0x4
 355 00f8 0E        		.byte	0xe
 356 00f9 0000 00D0 		.long	0xd0
 357 00fd 02        		.uleb128 0x2
 358 00fe 91        		.byte	0x91
 359 00ff 00        		.sleb128 0
 360 0100 02        		.uleb128 0x2
 361 0101 6275 6600 		.string	"buf"
 362 0105 04        		.byte	0x4
 363 0106 18        		.byte	0x18
 364 0107 0000 00D7 		.long	0xd7
 365 010b 02        		.uleb128 0x2
 366 010c 91        		.byte	0x91
 367 010d 04        		.sleb128 4
 368 010e 05        		.uleb128 0x5
 369 010f 0000 0000 		.long	.LASF4


 370 0113 04        		.byte	0x4
 371 0114 21        		.byte	0x21
 372 0115 0000 00D0 		.long	0xd0
 373 0119 02        		.uleb128 0x2
 374 011a 91        		.byte	0x91
 375 011b 08        		.sleb128 8
 376 011c 03        		.uleb128 0x3
 377 011d 6300      		.string	"c"
 378 011f 06        		.byte	0x6
 379 0120 08        		.byte	0x8
 380 0121 0000 0050 		.long	0x50
 381 0125 0000 0000 		.long	.LLST0
 382 0129 0000 0000 		.long	.LVUS0
 383 012d 03        		.uleb128 0x3
 384 012e 6900      		.string	"i"
 385 0130 07        		.byte	0x7
 386 0131 08        		.byte	0x8
 387 0132 0000 00D0 		.long	0xd0
 388 0136 0000 0000 		.long	.LLST1
 389 013a 0000 0000 		.long	.LVUS1
 390 013e 01        		.uleb128 0x1
 391 013f 0000 0000 		.long	.LVL3
 392 0143 0000 003E 		.long	0x3e
 393 0147 01        		.uleb128 0x1
 394 0148 0000 0000 		.long	.LVL6
 395 014c 0000 0026 		.long	0x26
 396 0150 01        		.uleb128 0x1
 397 0151 0000 0000 		.long	.LVL11
 398 0155 0000 0026 		.long	0x26
 399 0159 01        		.uleb128 0x1
 400 015a 0000 0000 		.long	.LVL12
 401 015e 0000 0026 		.long	0x26
 402 0162 01        		.uleb128 0x1
 403 0163 0000 0000 		.long	.LVL17
 404 0167 0000 0026 		.long	0x26
 405 016b 01        		.uleb128 0x1
 406 016c 0000 0000 		.long	.LVL18
 407 0170 0000 0026 		.long	0x26
 408 0174 01        		.uleb128 0x1
 409 0175 0000 0000 		.long	.LVL19
 410 0179 0000 0026 		.long	0x26
 411 017d 00        		.byte	0
 412 017e 00        		.byte	0
 413               		.section	.debug_abbrev,"",@progbits
 414               	.Ldebug_abbrev0:
 415 0000 01        		.uleb128 0x1
 416 0001 48        		.uleb128 0x48
 417 0002 00        		.byte	0
 418 0003 7D        		.uleb128 0x7d
 419 0004 01        		.uleb128 0x1
 420 0005 7F        		.uleb128 0x7f
 421 0006 13        		.uleb128 0x13
 422 0007 00        		.byte	0
 423 0008 00        		.byte	0
 424 0009 02        		.uleb128 0x2
 425 000a 05        		.uleb128 0x5
 426 000b 00        		.byte	0


 427 000c 03        		.uleb128 0x3
 428 000d 08        		.uleb128 0x8
 429 000e 3A        		.uleb128 0x3a
 430 000f 21        		.uleb128 0x21
 431 0010 01        		.sleb128 1
 432 0011 3B        		.uleb128 0x3b
 433 0012 0B        		.uleb128 0xb
 434 0013 39        		.uleb128 0x39
 435 0014 0B        		.uleb128 0xb
 436 0015 49        		.uleb128 0x49
 437 0016 13        		.uleb128 0x13
 438 0017 02        		.uleb128 0x2
 439 0018 18        		.uleb128 0x18
 440 0019 00        		.byte	0
 441 001a 00        		.byte	0
 442 001b 03        		.uleb128 0x3
 443 001c 34        		.uleb128 0x34
 444 001d 00        		.byte	0
 445 001e 03        		.uleb128 0x3
 446 001f 08        		.uleb128 0x8
 447 0020 3A        		.uleb128 0x3a
 448 0021 21        		.uleb128 0x21
 449 0022 01        		.sleb128 1
 450 0023 3B        		.uleb128 0x3b
 451 0024 0B        		.uleb128 0xb
 452 0025 39        		.uleb128 0x39
 453 0026 0B        		.uleb128 0xb
 454 0027 49        		.uleb128 0x49
 455 0028 13        		.uleb128 0x13
 456 0029 02        		.uleb128 0x2
 457 002a 17        		.uleb128 0x17
 458 002b B742      		.uleb128 0x2137
 459 002d 17        		.uleb128 0x17
 460 002e 00        		.byte	0
 461 002f 00        		.byte	0
 462 0030 04        		.uleb128 0x4
 463 0031 24        		.uleb128 0x24
 464 0032 00        		.byte	0
 465 0033 0B        		.uleb128 0xb
 466 0034 21        		.uleb128 0x21
 467 0035 01        		.sleb128 1
 468 0036 3E        		.uleb128 0x3e
 469 0037 0B        		.uleb128 0xb
 470 0038 03        		.uleb128 0x3
 471 0039 0E        		.uleb128 0xe
 472 003a 00        		.byte	0
 473 003b 00        		.byte	0
 474 003c 05        		.uleb128 0x5
 475 003d 05        		.uleb128 0x5
 476 003e 00        		.byte	0
 477 003f 03        		.uleb128 0x3
 478 0040 0E        		.uleb128 0xe
 479 0041 3A        		.uleb128 0x3a
 480 0042 21        		.uleb128 0x21
 481 0043 01        		.sleb128 1
 482 0044 3B        		.uleb128 0x3b
 483 0045 0B        		.uleb128 0xb


 484 0046 39        		.uleb128 0x39
 485 0047 0B        		.uleb128 0xb
 486 0048 49        		.uleb128 0x49
 487 0049 13        		.uleb128 0x13
 488 004a 02        		.uleb128 0x2
 489 004b 18        		.uleb128 0x18
 490 004c 00        		.byte	0
 491 004d 00        		.byte	0
 492 004e 06        		.uleb128 0x6
 493 004f 11        		.uleb128 0x11
 494 0050 01        		.byte	0x1
 495 0051 25        		.uleb128 0x25
 496 0052 0E        		.uleb128 0xe
 497 0053 13        		.uleb128 0x13
 498 0054 0B        		.uleb128 0xb
 499 0055 03        		.uleb128 0x3
 500 0056 0E        		.uleb128 0xe
 501 0057 1B        		.uleb128 0x1b
 502 0058 0E        		.uleb128 0xe
 503 0059 11        		.uleb128 0x11
 504 005a 01        		.uleb128 0x1
 505 005b 12        		.uleb128 0x12
 506 005c 06        		.uleb128 0x6
 507 005d 10        		.uleb128 0x10
 508 005e 17        		.uleb128 0x17
 509 005f 00        		.byte	0
 510 0060 00        		.byte	0
 511 0061 07        		.uleb128 0x7
 512 0062 2E        		.uleb128 0x2e
 513 0063 01        		.byte	0x1
 514 0064 3F        		.uleb128 0x3f
 515 0065 19        		.uleb128 0x19
 516 0066 03        		.uleb128 0x3
 517 0067 0E        		.uleb128 0xe
 518 0068 3A        		.uleb128 0x3a
 519 0069 0B        		.uleb128 0xb
 520 006a 3B        		.uleb128 0x3b
 521 006b 0B        		.uleb128 0xb
 522 006c 39        		.uleb128 0x39
 523 006d 0B        		.uleb128 0xb
 524 006e 27        		.uleb128 0x27
 525 006f 19        		.uleb128 0x19
 526 0070 3C        		.uleb128 0x3c
 527 0071 19        		.uleb128 0x19
 528 0072 01        		.uleb128 0x1
 529 0073 13        		.uleb128 0x13
 530 0074 00        		.byte	0
 531 0075 00        		.byte	0
 532 0076 08        		.uleb128 0x8
 533 0077 05        		.uleb128 0x5
 534 0078 00        		.byte	0
 535 0079 49        		.uleb128 0x49
 536 007a 13        		.uleb128 0x13
 537 007b 00        		.byte	0
 538 007c 00        		.byte	0
 539 007d 09        		.uleb128 0x9
 540 007e 2E        		.uleb128 0x2e


 541 007f 01        		.byte	0x1
 542 0080 3F        		.uleb128 0x3f
 543 0081 19        		.uleb128 0x19
 544 0082 03        		.uleb128 0x3
 545 0083 0E        		.uleb128 0xe
 546 0084 3A        		.uleb128 0x3a
 547 0085 0B        		.uleb128 0xb
 548 0086 3B        		.uleb128 0x3b
 549 0087 0B        		.uleb128 0xb
 550 0088 39        		.uleb128 0x39
 551 0089 0B        		.uleb128 0xb
 552 008a 49        		.uleb128 0x49
 553 008b 13        		.uleb128 0x13
 554 008c 3C        		.uleb128 0x3c
 555 008d 19        		.uleb128 0x19
 556 008e 01        		.uleb128 0x1
 557 008f 13        		.uleb128 0x13
 558 0090 00        		.byte	0
 559 0091 00        		.byte	0
 560 0092 0A        		.uleb128 0xa
 561 0093 18        		.uleb128 0x18
 562 0094 00        		.byte	0
 563 0095 00        		.byte	0
 564 0096 00        		.byte	0
 565 0097 0B        		.uleb128 0xb
 566 0098 2E        		.uleb128 0x2e
 567 0099 01        		.byte	0x1
 568 009a 3F        		.uleb128 0x3f
 569 009b 19        		.uleb128 0x19
 570 009c 03        		.uleb128 0x3
 571 009d 0E        		.uleb128 0xe
 572 009e 3A        		.uleb128 0x3a
 573 009f 0B        		.uleb128 0xb
 574 00a0 3B        		.uleb128 0x3b
 575 00a1 0B        		.uleb128 0xb
 576 00a2 39        		.uleb128 0x39
 577 00a3 0B        		.uleb128 0xb
 578 00a4 27        		.uleb128 0x27
 579 00a5 19        		.uleb128 0x19
 580 00a6 49        		.uleb128 0x49
 581 00a7 13        		.uleb128 0x13
 582 00a8 11        		.uleb128 0x11
 583 00a9 01        		.uleb128 0x1
 584 00aa 12        		.uleb128 0x12
 585 00ab 06        		.uleb128 0x6
 586 00ac 40        		.uleb128 0x40
 587 00ad 18        		.uleb128 0x18
 588 00ae 7A        		.uleb128 0x7a
 589 00af 19        		.uleb128 0x19
 590 00b0 01        		.uleb128 0x1
 591 00b1 13        		.uleb128 0x13
 592 00b2 00        		.byte	0
 593 00b3 00        		.byte	0
 594 00b4 0C        		.uleb128 0xc
 595 00b5 34        		.uleb128 0x34
 596 00b6 00        		.byte	0
 597 00b7 03        		.uleb128 0x3


 598 00b8 08        		.uleb128 0x8
 599 00b9 3A        		.uleb128 0x3a
 600 00ba 0B        		.uleb128 0xb
 601 00bb 3B        		.uleb128 0x3b
 602 00bc 0B        		.uleb128 0xb
 603 00bd 39        		.uleb128 0x39
 604 00be 0B        		.uleb128 0xb
 605 00bf 49        		.uleb128 0x49
 606 00c0 13        		.uleb128 0x13
 607 00c1 00        		.byte	0
 608 00c2 00        		.byte	0
 609 00c3 0D        		.uleb128 0xd
 610 00c4 24        		.uleb128 0x24
 611 00c5 00        		.byte	0
 612 00c6 0B        		.uleb128 0xb
 613 00c7 0B        		.uleb128 0xb
 614 00c8 3E        		.uleb128 0x3e
 615 00c9 0B        		.uleb128 0xb
 616 00ca 03        		.uleb128 0x3
 617 00cb 08        		.uleb128 0x8
 618 00cc 00        		.byte	0
 619 00cd 00        		.byte	0
 620 00ce 0E        		.uleb128 0xe
 621 00cf 0F        		.uleb128 0xf
 622 00d0 00        		.byte	0
 623 00d1 0B        		.uleb128 0xb
 624 00d2 0B        		.uleb128 0xb
 625 00d3 49        		.uleb128 0x49
 626 00d4 13        		.uleb128 0x13
 627 00d5 00        		.byte	0
 628 00d6 00        		.byte	0
 629 00d7 0F        		.uleb128 0xf
 630 00d8 2E        		.uleb128 0x2e
 631 00d9 01        		.byte	0x1
 632 00da 3F        		.uleb128 0x3f
 633 00db 19        		.uleb128 0x19
 634 00dc 03        		.uleb128 0x3
 635 00dd 0E        		.uleb128 0xe
 636 00de 3A        		.uleb128 0x3a
 637 00df 0B        		.uleb128 0xb
 638 00e0 3B        		.uleb128 0x3b
 639 00e1 0B        		.uleb128 0xb
 640 00e2 39        		.uleb128 0x39
 641 00e3 0B        		.uleb128 0xb
 642 00e4 27        		.uleb128 0x27
 643 00e5 19        		.uleb128 0x19
 644 00e6 49        		.uleb128 0x49
 645 00e7 13        		.uleb128 0x13
 646 00e8 11        		.uleb128 0x11
 647 00e9 01        		.uleb128 0x1
 648 00ea 12        		.uleb128 0x12
 649 00eb 06        		.uleb128 0x6
 650 00ec 40        		.uleb128 0x40
 651 00ed 18        		.uleb128 0x18
 652 00ee 7A        		.uleb128 0x7a
 653 00ef 19        		.uleb128 0x19
 654 00f0 00        		.byte	0


 655 00f1 00        		.byte	0
 656 00f2 00        		.byte	0
 657               		.section	.debug_loclists,"",@progbits
 658 0000 0000 00E3 		.long	.Ldebug_loc3-.Ldebug_loc2
 659               	.Ldebug_loc2:
 660 0004 0005      		.word	0x5
 661 0006 04        		.byte	0x4
 662 0007 00        		.byte	0
 663 0008 0000 0000 		.long	0
 664               	.Ldebug_loc0:
 665               	.LVUS2:
 666 000c 02        		.uleb128 .LVU50
 667 000d 00        		.uleb128 .LVU51
 668 000e 00        		.uleb128 .LVU51
 669 000f 00        		.uleb128 .LVU53
 670 0010 00        		.uleb128 .LVU53
 671 0011 03        		.uleb128 .LVU58
 672 0012 03        		.uleb128 .LVU58
 673 0013 00        		.uleb128 .LVU59
 674 0014 00        		.uleb128 .LVU60
 675 0015 03        		.uleb128 .LVU66
 676 0016 03        		.uleb128 .LVU66
 677 0017 00        		.uleb128 0
 678               	.LLST2:
 679 0018 04        		.byte	0x4
 680 0019 9801      		.uleb128 .LVL22-.Ltext0
 681 001b A801      		.uleb128 .LVL23-.Ltext0
 682 001d 02        		.uleb128 0x2
 683 001e 30        		.byte	0x30
 684 001f 9F        		.byte	0x9f
 685 0020 04        		.byte	0x4
 686 0021 A801      		.uleb128 .LVL23-.Ltext0
 687 0023 AA01      		.uleb128 .LVL24-.Ltext0
 688 0025 07        		.uleb128 0x7
 689 0026 7A        		.byte	0x7a
 690 0027 00        		.sleb128 0
 691 0028 91        		.byte	0x91
 692 0029 74        		.sleb128 -12
 693 002a 06        		.byte	0x6
 694 002b 1C        		.byte	0x1c
 695 002c 9F        		.byte	0x9f
 696 002d 04        		.byte	0x4
 697 002e AA01      		.uleb128 .LVL24-.Ltext0
 698 0030 BA01      		.uleb128 .LVL25-.Ltext0
 699 0032 08        		.uleb128 0x8
 700 0033 91        		.byte	0x91
 701 0034 74        		.sleb128 -12
 702 0035 06        		.byte	0x6
 703 0036 20        		.byte	0x20
 704 0037 7A        		.byte	0x7a
 705 0038 00        		.sleb128 0
 706 0039 22        		.byte	0x22
 707 003a 9F        		.byte	0x9f
 708 003b 04        		.byte	0x4
 709 003c BA01      		.uleb128 .LVL25-.Ltext0
 710 003e C001      		.uleb128 .LVL26-.Ltext0
 711 0040 07        		.uleb128 0x7


 712 0041 7A        		.byte	0x7a
 713 0042 00        		.sleb128 0
 714 0043 91        		.byte	0x91
 715 0044 74        		.sleb128 -12
 716 0045 06        		.byte	0x6
 717 0046 1C        		.byte	0x1c
 718 0047 9F        		.byte	0x9f
 719 0048 04        		.byte	0x4
 720 0049 C801      		.uleb128 .LVL27-.Ltext0
 721 004b DE01      		.uleb128 .LVL29-.Ltext0
 722 004d 08        		.uleb128 0x8
 723 004e 91        		.byte	0x91
 724 004f 74        		.sleb128 -12
 725 0050 06        		.byte	0x6
 726 0051 20        		.byte	0x20
 727 0052 7A        		.byte	0x7a
 728 0053 00        		.sleb128 0
 729 0054 22        		.byte	0x22
 730 0055 9F        		.byte	0x9f
 731 0056 04        		.byte	0x4
 732 0057 DE01      		.uleb128 .LVL29-.Ltext0
 733 0059 E601      		.uleb128 .LFE1-.Ltext0
 734 005b 07        		.uleb128 0x7
 735 005c 7A        		.byte	0x7a
 736 005d 00        		.sleb128 0
 737 005e 91        		.byte	0x91
 738 005f 74        		.sleb128 -12
 739 0060 06        		.byte	0x6
 740 0061 1C        		.byte	0x1c
 741 0062 9F        		.byte	0x9f
 742 0063 00        		.byte	0
 743               	.LVUS0:
 744 0064 00        		.uleb128 .LVU10
 745 0065 00        		.uleb128 .LVU16
 746 0066 00        		.uleb128 .LVU16
 747 0067 00        		.uleb128 .LVU24
 748 0068 00        		.uleb128 .LVU25
 749 0069 00        		.uleb128 .LVU26
 750 006a 00        		.uleb128 .LVU26
 751 006b 00        		.uleb128 .LVU34
 752 006c 00        		.uleb128 .LVU35
 753 006d 00        		.uleb128 .LVU39
 754 006e 00        		.uleb128 .LVU39
 755 006f 00        		.uleb128 0
 756               	.LLST0:
 757 0070 04        		.byte	0x4
 758 0071 22        		.uleb128 .LVL4-.Ltext0
 759 0072 36        		.uleb128 .LVL5-.Ltext0
 760 0073 01        		.uleb128 0x1
 761 0074 50        		.byte	0x50
 762 0075 04        		.byte	0x4
 763 0076 36        		.uleb128 .LVL5-.Ltext0
 764 0077 48        		.uleb128 .LVL9-.Ltext0
 765 0078 01        		.uleb128 0x1
 766 0079 52        		.byte	0x52
 767 007a 04        		.byte	0x4
 768 007b 50        		.uleb128 .LVL10-.Ltext0


 769 007c 55        		.uleb128 .LVL11-1-.Ltext0
 770 007d 01        		.uleb128 0x1
 771 007e 50        		.byte	0x50
 772 007f 04        		.byte	0x4
 773 0080 55        		.uleb128 .LVL11-1-.Ltext0
 774 0081 6C        		.uleb128 .LVL14-.Ltext0
 775 0082 01        		.uleb128 0x1
 776 0083 52        		.byte	0x52
 777 0084 04        		.byte	0x4
 778 0085 6E        		.uleb128 .LVL15-.Ltext0
 779 0086 79        		.uleb128 .LVL17-1-.Ltext0
 780 0087 01        		.uleb128 0x1
 781 0088 50        		.byte	0x50
 782 0089 04        		.byte	0x4
 783 008a 79        		.uleb128 .LVL17-1-.Ltext0
 784 008b 9001      		.uleb128 .LFE0-.Ltext0
 785 008d 01        		.uleb128 0x1
 786 008e 52        		.byte	0x52
 787 008f 00        		.byte	0
 788               	.LVUS1:
 789 0090 03        		.uleb128 .LVU5
 790 0091 00        		.uleb128 .LVU8
 791 0092 00        		.uleb128 .LVU8
 792 0093 00        		.uleb128 .LVU21
 793 0094 00        		.uleb128 .LVU21
 794 0095 00        		.uleb128 .LVU22
 795 0096 00        		.uleb128 .LVU25
 796 0097 00        		.uleb128 .LVU32
 797 0098 00        		.uleb128 .LVU32
 798 0099 00        		.uleb128 .LVU34
 799 009a 00        		.uleb128 .LVU34
 800 009b 00        		.uleb128 .LVU35
 801 009c 00        		.uleb128 .LVU35
 802 009d 00        		.uleb128 .LVU38
 803 009e 00        		.uleb128 .LVU38
 804 009f 01        		.uleb128 .LVU42
 805 00a0 01        		.uleb128 .LVU42
 806 00a1 02        		.uleb128 .LVU43
 807 00a2 02        		.uleb128 .LVU43
 808 00a3 00        		.uleb128 .LVU44
 809               	.LLST1:
 810 00a4 04        		.byte	0x4
 811 00a5 0C        		.uleb128 .LVL1-.Ltext0
 812 00a6 1E        		.uleb128 .LVL2-.Ltext0
 813 00a7 02        		.uleb128 0x2
 814 00a8 30        		.byte	0x30
 815 00a9 9F        		.byte	0x9f
 816 00aa 04        		.byte	0x4
 817 00ab 1E        		.uleb128 .LVL2-.Ltext0
 818 00ac 42        		.uleb128 .LVL7-.Ltext0
 819 00ad 01        		.uleb128 0x1
 820 00ae 53        		.byte	0x53
 821 00af 04        		.byte	0x4
 822 00b0 42        		.uleb128 .LVL7-.Ltext0
 823 00b1 44        		.uleb128 .LVL8-.Ltext0
 824 00b2 03        		.uleb128 0x3
 825 00b3 73        		.byte	0x73


 826 00b4 7F        		.sleb128 -1
 827 00b5 9F        		.byte	0x9f
 828 00b6 04        		.byte	0x4
 829 00b7 50        		.uleb128 .LVL10-.Ltext0
 830 00b8 64        		.uleb128 .LVL13-.Ltext0
 831 00b9 01        		.uleb128 0x1
 832 00ba 53        		.byte	0x53
 833 00bb 04        		.byte	0x4
 834 00bc 64        		.uleb128 .LVL13-.Ltext0
 835 00bd 6C        		.uleb128 .LVL14-.Ltext0
 836 00be 03        		.uleb128 0x3
 837 00bf 73        		.byte	0x73
 838 00c0 7F        		.sleb128 -1
 839 00c1 9F        		.byte	0x9f
 840 00c2 04        		.byte	0x4
 841 00c3 6C        		.uleb128 .LVL14-.Ltext0
 842 00c4 6E        		.uleb128 .LVL15-.Ltext0
 843 00c5 03        		.uleb128 0x3
 844 00c6 70        		.byte	0x70
 845 00c7 7F        		.sleb128 -1
 846 00c8 9F        		.byte	0x9f
 847 00c9 04        		.byte	0x4
 848 00ca 6E        		.uleb128 .LVL15-.Ltext0
 849 00cb 74        		.uleb128 .LVL16-.Ltext0
 850 00cc 01        		.uleb128 0x1
 851 00cd 53        		.byte	0x53
 852 00ce 04        		.byte	0x4
 853 00cf 74        		.uleb128 .LVL16-.Ltext0
 854 00d0 8601      		.uleb128 .LVL19-.Ltext0
 855 00d2 03        		.uleb128 0x3
 856 00d3 73        		.byte	0x73
 857 00d4 01        		.sleb128 1
 858 00d5 9F        		.byte	0x9f
 859 00d6 04        		.byte	0x4
 860 00d7 8601      		.uleb128 .LVL19-.Ltext0
 861 00d9 8601      		.uleb128 .LVL19-.Ltext0
 862 00db 01        		.uleb128 0x1
 863 00dc 53        		.byte	0x53
 864 00dd 04        		.byte	0x4
 865 00de 8601      		.uleb128 .LVL19-.Ltext0
 866 00e0 8A01      		.uleb128 .LVL20-.Ltext0
 867 00e2 03        		.uleb128 0x3
 868 00e3 73        		.byte	0x73
 869 00e4 7F        		.sleb128 -1
 870 00e5 9F        		.byte	0x9f
 871 00e6 00        		.byte	0
 872               	.Ldebug_loc3:
 873               		.section	.debug_aranges,"",@progbits
 874 0000 0000 001C 		.long	0x1c
 875 0004 0002      		.word	0x2
 876 0006 0000 0000 		.long	.Ldebug_info0
 877 000a 04        		.byte	0x4
 878 000b 00        		.byte	0
 879 000c 0000      		.word	0
 880 000e 0000      		.word	0
 881 0010 0000 0000 		.long	.Ltext0
 882 0014 0000 00E6 		.long	.Letext0-.Ltext0


 883 0018 0000 0000 		.long	0
 884 001c 0000 0000 		.long	0
 885               		.section	.debug_line,"",@progbits
 886               	.Ldebug_line0:
 887 0000 0000 0114 		.section	.debug_str,"MS",@progbits,1
 887      0003 0000 
 887      0020 0201 
 887      FB0E 0D00 
 887      0101 0101 
 888               	.LASF0:
 889 0000 6F75 7462 		.string	"outbyte"
 889      7974 6500 
 890               	.LASF4:
 891 0008 6E62 7974 		.string	"nbytes"
 891      6573 00
 892               	.LASF9:
 893 000f 7265 6164 		.string	"read"
 893      00
 894               	.LASF3:
 895 0014 6368 6172 		.string	"char"
 895      00
 896               	.LASF6:
 897 0019 6373 7973 		.string	"csys68k.c"
 897      3638 6B2E 
 897      6300 
 898               	.LASF5:
 899 0023 474E 5520 		.string	"GNU C17 11.4.0 -mcpu=68000 -msoft-float -g -O2 -fomit-frame-pointer"
 899      4331 3720 
 899      3131 2E34 
 899      2E30 202D 
 899      6D63 7075 
 900               	.LASF2:
 901 0067 756E 7369 		.string	"unsigned char"
 901      676E 6564 
 901      2063 6861 
 901      7200 
 902               	.LASF8:
 903 0075 7772 6974 		.string	"write"
 903      6500 
 904               	.LASF7:
 905 007b 2F68 6F6D 		.string	"/home/students/5443962251"
 905      652F 7374 
 905      7564 656E 
 905      7473 2F35 
 905      3434 3339 
 906               	.LASF1:
 907 0095 696E 6279 		.string	"inbyte"
 907      7465 00
 908               		.ident	"GCC: (GNU) 11.4.0"




   1               	#NO_APP
   2               		.file	"test1.c"
   3               		.text
   4               	.Ltext0:
   5               		.cfi_sections	.debug_frame
   6               		.section	.rodata.str1.1,"aMS",@progbits,1
   7               	.LC0:
   8 0000 4E61 7061 		.string	"Napat limsuwan"
   8      7420 6C69 
   8      6D73 7577 
   8      616E 00
   9               	.LC1:
  10 000f 2563 00   		.string	"%c"
  11               		.section	.text.startup,"ax",@progbits
  12               		.align	2
  13               		.globl	main
  14               		.type	main, @function
  15               	main:
  16               	.LFB3:
  17               		.file 1 "test1.c"
   1:test1.c       **** 
   2:test1.c       **** #include <stdio.h>
   3:test1.c       **** 
   4:test1.c       **** int main() {   
  18               		.loc 1 4 12 view -0
  19               		.cfi_startproc
  20 0000 598F      		subq.l #4,%sp
  21               		.cfi_def_cfa_offset 8
  22 0002 48E7 2030 		movem.l #8240,-(%sp)
  23               		.cfi_def_cfa_offset 20
  24               		.cfi_offset 2, -20
  25               		.cfi_offset 10, -16
  26               		.cfi_offset 11, -12
   5:test1.c       ****     char buf;
  27               		.loc 1 5 5 view .LVU1
   6:test1.c       ****     printf("Napat limsuwan\n");   // Check if the program is running
  28               		.loc 1 6 5 view .LVU2
  29 0006 4879 0000 		pea .LC0
  29      0000 
  30               		.cfi_def_cfa_offset 24
  31 000c 4EB9 0000 		jsr puts
  31      0000 
  32               	.LVL0:
  33 0012 588F      		addq.l #4,%sp
  34               		.cfi_def_cfa_offset 20
  35 0014 740F      		moveq #15,%d2
  36 0016 D48F      		add.l %sp,%d2
  37 0018 45F9 0000 		lea scanf,%a2
  37      0000 
   7:test1.c       ****     while(1) {
   8:test1.c       ****         scanf("%c", &buf);      // Read a character from the keyboard
   9:test1.c       ****         if (buf != 'q') {
  10:test1.c       ****             printf("%c", buf);  // Print the character
  38               		.loc 1 10 13 is_stmt 0 view .LVU3
  39 001e 47F9 0000 		lea putchar,%a3
  39      0000 
   7:test1.c       ****     while(1) {


  40               		.loc 1 7 5 is_stmt 1 view .LVU4
   8:test1.c       ****         if (buf != 'q') {
  41               		.loc 1 8 9 view .LVU5
  42 0024 2F02      		move.l %d2,-(%sp)
  43               		.cfi_def_cfa_offset 24
  44 0026 4879 0000 		pea .LC1
  44      0000 
  45               		.cfi_def_cfa_offset 28
  46 002c 4E92      		jsr (%a2)
  47               	.LVL1:
   9:test1.c       ****             printf("%c", buf);  // Print the character
  48               		.loc 1 9 9 view .LVU6
   9:test1.c       ****             printf("%c", buf);  // Print the character
  49               		.loc 1 9 17 is_stmt 0 view .LVU7
  50 002e 102F 0017 		move.b 23(%sp),%d0
   9:test1.c       ****             printf("%c", buf);  // Print the character
  51               		.loc 1 9 12 view .LVU8
  52 0032 508F      		addq.l #8,%sp
  53               		.cfi_def_cfa_offset 20
  54 0034 0C00 0071 		cmp.b #113,%d0
  55 0038 6720      		jeq .L2
  56               	.L6:
  57               		.loc 1 10 13 is_stmt 1 view .LVU9
  58 003a 4880      		ext.w %d0
  59 003c 3040      		move.w %d0,%a0
  60 003e 2F08      		move.l %a0,-(%sp)
  61               		.cfi_def_cfa_offset 24
  62 0040 4E93      		jsr (%a3)
  63               	.LVL2:
   7:test1.c       ****     while(1) {
  64               		.loc 1 7 10 view .LVU10
   8:test1.c       ****         if (buf != 'q') {
  65               		.loc 1 8 9 is_stmt 0 view .LVU11
  66 0042 588F      		addq.l #4,%sp
  67               		.cfi_def_cfa_offset 20
   7:test1.c       ****     while(1) {
  68               		.loc 1 7 5 is_stmt 1 view .LVU12
   8:test1.c       ****         if (buf != 'q') {
  69               		.loc 1 8 9 view .LVU13
  70 0044 2F02      		move.l %d2,-(%sp)
  71               		.cfi_def_cfa_offset 24
  72 0046 4879 0000 		pea .LC1
  72      0000 
  73               		.cfi_def_cfa_offset 28
  74 004c 4E92      		jsr (%a2)
  75               	.LVL3:
   9:test1.c       ****             printf("%c", buf);  // Print the character
  76               		.loc 1 9 9 view .LVU14
   9:test1.c       ****             printf("%c", buf);  // Print the character
  77               		.loc 1 9 17 is_stmt 0 view .LVU15
  78 004e 102F 0017 		move.b 23(%sp),%d0
   9:test1.c       ****             printf("%c", buf);  // Print the character
  79               		.loc 1 9 12 view .LVU16
  80 0052 508F      		addq.l #8,%sp
  81               		.cfi_def_cfa_offset 20
  82 0054 0C00 0071 		cmp.b #113,%d0
  83 0058 66E0      		jne .L6


  84               	.L2:
  11:test1.c       ****         } else {
  12:test1.c       ****             break;              // Exit the loop if the character is 'q'
  13:test1.c       ****         }
  14:test1.c       ****     }
  15:test1.c       ****     return 0;
  85               		.loc 1 15 5 is_stmt 1 view .LVU17
  16:test1.c       **** }
  86               		.loc 1 16 1 is_stmt 0 view .LVU18
  87 005a 7000      		moveq #0,%d0
  88 005c 4CDF 0C04 		movem.l (%sp)+,#3076
  89 0060 588F      		addq.l #4,%sp
  90 0062 4E75      		rts
  91               		.cfi_endproc
  92               	.LFE3:
  93               		.size	main, .-main
  94               		.text
  95               	.Letext0:
  96               		.file 2 "<built-in>"
  97               		.file 3 "/usr/local/m68k-elf/include/stdio.h"
  98               		.section	.debug_info,"",@progbits
  99               	.Ldebug_info0:
 100 0000 0000 0102 		.long	0x102
 101 0004 0005      		.word	0x5
 102 0006 01        		.byte	0x1
 103 0007 04        		.byte	0x4
 104 0008 0000 0000 		.long	.Ldebug_abbrev0
 105 000c 04        		.uleb128 0x4
 106 000d 0000 0000 		.long	.LASF17
 107 0011 1D        		.byte	0x1d
 108 0012 0000 0000 		.long	.LASF18
 109 0016 0000 0000 		.long	.LASF19
 110 001a 0000 0000 		.long	.LLRL0
 111 001e 0000 0000 		.long	0
 112 0022 0000 0000 		.long	.Ldebug_line0
 113 0026 01        		.uleb128 0x1
 114 0027 01        		.byte	0x1
 115 0028 06        		.byte	0x6
 116 0029 0000 0000 		.long	.LASF0
 117 002d 01        		.uleb128 0x1
 118 002e 01        		.byte	0x1
 119 002f 08        		.byte	0x8
 120 0030 0000 0000 		.long	.LASF1
 121 0034 01        		.uleb128 0x1
 122 0035 02        		.byte	0x2
 123 0036 05        		.byte	0x5
 124 0037 0000 0000 		.long	.LASF2
 125 003b 01        		.uleb128 0x1
 126 003c 02        		.byte	0x2
 127 003d 07        		.byte	0x7
 128 003e 0000 0000 		.long	.LASF3
 129 0042 01        		.uleb128 0x1
 130 0043 04        		.byte	0x4
 131 0044 05        		.byte	0x5
 132 0045 0000 0000 		.long	.LASF4
 133 0049 01        		.uleb128 0x1
 134 004a 04        		.byte	0x4


 135 004b 07        		.byte	0x7
 136 004c 0000 0000 		.long	.LASF5
 137 0050 01        		.uleb128 0x1
 138 0051 08        		.byte	0x8
 139 0052 05        		.byte	0x5
 140 0053 0000 0000 		.long	.LASF6
 141 0057 01        		.uleb128 0x1
 142 0058 08        		.byte	0x8
 143 0059 07        		.byte	0x7
 144 005a 0000 0000 		.long	.LASF7
 145 005e 01        		.uleb128 0x1
 146 005f 0C        		.byte	0xc
 147 0060 04        		.byte	0x4
 148 0061 0000 0000 		.long	.LASF8
 149 0065 01        		.uleb128 0x1
 150 0066 04        		.byte	0x4
 151 0067 07        		.byte	0x7
 152 0068 0000 0000 		.long	.LASF9
 153 006c 05        		.uleb128 0x5
 154 006d 04        		.byte	0x4
 155 006e 05        		.byte	0x5
 156 006f 696E 7400 		.string	"int"
 157 0073 01        		.uleb128 0x1
 158 0074 01        		.byte	0x1
 159 0075 06        		.byte	0x6
 160 0076 0000 0000 		.long	.LASF10
 161 007a 06        		.uleb128 0x6
 162 007b 0000 0073 		.long	0x73
 163 007f 07        		.uleb128 0x7
 164 0080 04        		.byte	0x4
 165 0081 0000 007A 		.long	0x7a
 166 0085 08        		.uleb128 0x8
 167 0086 0000 0000 		.long	.LASF12
 168 008a 03        		.byte	0x3
 169 008b D0        		.byte	0xd0
 170 008c 05        		.byte	0x5
 171 008d 0000 006C 		.long	0x6c
 172 0091 0000 009C 		.long	0x9c
 173 0095 09        		.uleb128 0x9
 174 0096 0000 007F 		.long	0x7f
 175 009a 0A        		.uleb128 0xa
 176 009b 00        		.byte	0
 177 009c 0B        		.uleb128 0xb
 178 009d 0000 0000 		.long	.LASF20
 179 00a1 01        		.byte	0x1
 180 00a2 04        		.byte	0x4
 181 00a3 05        		.byte	0x5
 182 00a4 0000 006C 		.long	0x6c
 183 00a8 0000 0000 		.long	.LFB3
 184 00ac 0000 0064 		.long	.LFE3-.LFB3
 185 00b0 01        		.uleb128 0x1
 186 00b1 9C        		.byte	0x9c
 187 00b2 0000 00EA 		.long	0xea
 188 00b6 0C        		.uleb128 0xc
 189 00b7 6275 6600 		.string	"buf"
 190 00bb 01        		.byte	0x1
 191 00bc 05        		.byte	0x5


 192 00bd 0A        		.byte	0xa
 193 00be 0000 0073 		.long	0x73
 194 00c2 02        		.uleb128 0x2
 195 00c3 91        		.byte	0x91
 196 00c4 7B        		.sleb128 -5
 197 00c5 02        		.uleb128 0x2
 198 00c6 0000 0000 		.long	.LVL0
 199 00ca 0000 00EA 		.long	0xea
 200 00ce 02        		.uleb128 0x2
 201 00cf 0000 0000 		.long	.LVL1
 202 00d3 0000 00F3 		.long	0xf3
 203 00d7 02        		.uleb128 0x2
 204 00d8 0000 0000 		.long	.LVL2
 205 00dc 0000 00FC 		.long	0xfc
 206 00e0 02        		.uleb128 0x2
 207 00e1 0000 0000 		.long	.LVL3
 208 00e5 0000 00F3 		.long	0xf3
 209 00e9 00        		.byte	0
 210 00ea 03        		.uleb128 0x3
 211 00eb 0000 0000 		.long	.LASF11
 212 00ef 0000 0000 		.long	.LASF13
 213 00f3 03        		.uleb128 0x3
 214 00f4 0000 0000 		.long	.LASF12
 215 00f8 0000 0000 		.long	.LASF14
 216 00fc 03        		.uleb128 0x3
 217 00fd 0000 0000 		.long	.LASF15
 218 0101 0000 0000 		.long	.LASF16
 219 0105 00        		.byte	0
 220               		.section	.debug_abbrev,"",@progbits
 221               	.Ldebug_abbrev0:
 222 0000 01        		.uleb128 0x1
 223 0001 24        		.uleb128 0x24
 224 0002 00        		.byte	0
 225 0003 0B        		.uleb128 0xb
 226 0004 0B        		.uleb128 0xb
 227 0005 3E        		.uleb128 0x3e
 228 0006 0B        		.uleb128 0xb
 229 0007 03        		.uleb128 0x3
 230 0008 0E        		.uleb128 0xe
 231 0009 00        		.byte	0
 232 000a 00        		.byte	0
 233 000b 02        		.uleb128 0x2
 234 000c 48        		.uleb128 0x48
 235 000d 00        		.byte	0
 236 000e 7D        		.uleb128 0x7d
 237 000f 01        		.uleb128 0x1
 238 0010 7F        		.uleb128 0x7f
 239 0011 13        		.uleb128 0x13
 240 0012 00        		.byte	0
 241 0013 00        		.byte	0
 242 0014 03        		.uleb128 0x3
 243 0015 2E        		.uleb128 0x2e
 244 0016 00        		.byte	0
 245 0017 3F        		.uleb128 0x3f
 246 0018 19        		.uleb128 0x19
 247 0019 3C        		.uleb128 0x3c
 248 001a 19        		.uleb128 0x19


 249 001b 6E        		.uleb128 0x6e
 250 001c 0E        		.uleb128 0xe
 251 001d 03        		.uleb128 0x3
 252 001e 0E        		.uleb128 0xe
 253 001f 3A        		.uleb128 0x3a
 254 0020 21        		.uleb128 0x21
 255 0021 02        		.sleb128 2
 256 0022 3B        		.uleb128 0x3b
 257 0023 21        		.uleb128 0x21
 258 0024 00        		.sleb128 0
 259 0025 00        		.byte	0
 260 0026 00        		.byte	0
 261 0027 04        		.uleb128 0x4
 262 0028 11        		.uleb128 0x11
 263 0029 01        		.byte	0x1
 264 002a 25        		.uleb128 0x25
 265 002b 0E        		.uleb128 0xe
 266 002c 13        		.uleb128 0x13
 267 002d 0B        		.uleb128 0xb
 268 002e 03        		.uleb128 0x3
 269 002f 0E        		.uleb128 0xe
 270 0030 1B        		.uleb128 0x1b
 271 0031 0E        		.uleb128 0xe
 272 0032 55        		.uleb128 0x55
 273 0033 17        		.uleb128 0x17
 274 0034 11        		.uleb128 0x11
 275 0035 01        		.uleb128 0x1
 276 0036 10        		.uleb128 0x10
 277 0037 17        		.uleb128 0x17
 278 0038 00        		.byte	0
 279 0039 00        		.byte	0
 280 003a 05        		.uleb128 0x5
 281 003b 24        		.uleb128 0x24
 282 003c 00        		.byte	0
 283 003d 0B        		.uleb128 0xb
 284 003e 0B        		.uleb128 0xb
 285 003f 3E        		.uleb128 0x3e
 286 0040 0B        		.uleb128 0xb
 287 0041 03        		.uleb128 0x3
 288 0042 08        		.uleb128 0x8
 289 0043 00        		.byte	0
 290 0044 00        		.byte	0
 291 0045 06        		.uleb128 0x6
 292 0046 26        		.uleb128 0x26
 293 0047 00        		.byte	0
 294 0048 49        		.uleb128 0x49
 295 0049 13        		.uleb128 0x13
 296 004a 00        		.byte	0
 297 004b 00        		.byte	0
 298 004c 07        		.uleb128 0x7
 299 004d 0F        		.uleb128 0xf
 300 004e 00        		.byte	0
 301 004f 0B        		.uleb128 0xb
 302 0050 0B        		.uleb128 0xb
 303 0051 49        		.uleb128 0x49
 304 0052 13        		.uleb128 0x13
 305 0053 00        		.byte	0


 306 0054 00        		.byte	0
 307 0055 08        		.uleb128 0x8
 308 0056 2E        		.uleb128 0x2e
 309 0057 01        		.byte	0x1
 310 0058 3F        		.uleb128 0x3f
 311 0059 19        		.uleb128 0x19
 312 005a 03        		.uleb128 0x3
 313 005b 0E        		.uleb128 0xe
 314 005c 3A        		.uleb128 0x3a
 315 005d 0B        		.uleb128 0xb
 316 005e 3B        		.uleb128 0x3b
 317 005f 0B        		.uleb128 0xb
 318 0060 39        		.uleb128 0x39
 319 0061 0B        		.uleb128 0xb
 320 0062 27        		.uleb128 0x27
 321 0063 19        		.uleb128 0x19
 322 0064 49        		.uleb128 0x49
 323 0065 13        		.uleb128 0x13
 324 0066 3C        		.uleb128 0x3c
 325 0067 19        		.uleb128 0x19
 326 0068 01        		.uleb128 0x1
 327 0069 13        		.uleb128 0x13
 328 006a 00        		.byte	0
 329 006b 00        		.byte	0
 330 006c 09        		.uleb128 0x9
 331 006d 05        		.uleb128 0x5
 332 006e 00        		.byte	0
 333 006f 49        		.uleb128 0x49
 334 0070 13        		.uleb128 0x13
 335 0071 00        		.byte	0
 336 0072 00        		.byte	0
 337 0073 0A        		.uleb128 0xa
 338 0074 18        		.uleb128 0x18
 339 0075 00        		.byte	0
 340 0076 00        		.byte	0
 341 0077 00        		.byte	0
 342 0078 0B        		.uleb128 0xb
 343 0079 2E        		.uleb128 0x2e
 344 007a 01        		.byte	0x1
 345 007b 3F        		.uleb128 0x3f
 346 007c 19        		.uleb128 0x19
 347 007d 03        		.uleb128 0x3
 348 007e 0E        		.uleb128 0xe
 349 007f 3A        		.uleb128 0x3a
 350 0080 0B        		.uleb128 0xb
 351 0081 3B        		.uleb128 0x3b
 352 0082 0B        		.uleb128 0xb
 353 0083 39        		.uleb128 0x39
 354 0084 0B        		.uleb128 0xb
 355 0085 49        		.uleb128 0x49
 356 0086 13        		.uleb128 0x13
 357 0087 11        		.uleb128 0x11
 358 0088 01        		.uleb128 0x1
 359 0089 12        		.uleb128 0x12
 360 008a 06        		.uleb128 0x6
 361 008b 40        		.uleb128 0x40
 362 008c 18        		.uleb128 0x18


 363 008d 7A        		.uleb128 0x7a
 364 008e 19        		.uleb128 0x19
 365 008f 01        		.uleb128 0x1
 366 0090 13        		.uleb128 0x13
 367 0091 00        		.byte	0
 368 0092 00        		.byte	0
 369 0093 0C        		.uleb128 0xc
 370 0094 34        		.uleb128 0x34
 371 0095 00        		.byte	0
 372 0096 03        		.uleb128 0x3
 373 0097 08        		.uleb128 0x8
 374 0098 3A        		.uleb128 0x3a
 375 0099 0B        		.uleb128 0xb
 376 009a 3B        		.uleb128 0x3b
 377 009b 0B        		.uleb128 0xb
 378 009c 39        		.uleb128 0x39
 379 009d 0B        		.uleb128 0xb
 380 009e 49        		.uleb128 0x49
 381 009f 13        		.uleb128 0x13
 382 00a0 02        		.uleb128 0x2
 383 00a1 18        		.uleb128 0x18
 384 00a2 00        		.byte	0
 385 00a3 00        		.byte	0
 386 00a4 00        		.byte	0
 387               		.section	.debug_aranges,"",@progbits
 388 0000 0000 001C 		.long	0x1c
 389 0004 0002      		.word	0x2
 390 0006 0000 0000 		.long	.Ldebug_info0
 391 000a 04        		.byte	0x4
 392 000b 00        		.byte	0
 393 000c 0000      		.word	0
 394 000e 0000      		.word	0
 395 0010 0000 0000 		.long	.LFB3
 396 0014 0000 0064 		.long	.LFE3-.LFB3
 397 0018 0000 0000 		.long	0
 398 001c 0000 0000 		.long	0
 399               		.section	.debug_rnglists,"",@progbits
 400               	.Ldebug_ranges0:
 401 0000 0000 000F 		.long	.Ldebug_ranges3-.Ldebug_ranges2
 402               	.Ldebug_ranges2:
 403 0004 0005      		.word	0x5
 404 0006 04        		.byte	0x4
 405 0007 00        		.byte	0
 406 0008 0000 0000 		.long	0
 407               	.LLRL0:
 408 000c 07        		.byte	0x7
 409 000d 0000 0000 		.long	.LFB3
 410 0011 64        		.uleb128 .LFE3-.LFB3
 411 0012 00        		.byte	0
 412               	.Ldebug_ranges3:
 413               		.section	.debug_line,"",@progbits
 414               	.Ldebug_line0:
 415 0000 0000 00A1 		.section	.debug_str,"MS",@progbits,1
 415      0003 0000 
 415      0053 0201 
 415      FB0E 0D00 
 415      0101 0101 


 416               	.LASF6:
 417 0000 6C6F 6E67 		.string	"long long int"
 417      206C 6F6E 
 417      6720 696E 
 417      7400 
 418               	.LASF15:
 419 000e 7075 7463 		.string	"putchar"
 419      6861 7200 
 420               	.LASF9:
 421 0016 756E 7369 		.string	"unsigned int"
 421      676E 6564 
 421      2069 6E74 
 421      00
 422               	.LASF17:
 423 0023 474E 5520 		.string	"GNU C17 11.4.0 -mcpu=68000 -msoft-float -g -O2 -fomit-frame-pointer"
 423      4331 3720 
 423      3131 2E34 
 423      2E30 202D 
 423      6D63 7075 
 424               	.LASF11:
 425 0067 7075 7473 		.string	"puts"
 425      00
 426               	.LASF20:
 427 006c 6D61 696E 		.string	"main"
 427      00
 428               	.LASF13:
 429 0071 5F5F 6275 		.string	"__builtin_puts"
 429      696C 7469 
 429      6E5F 7075 
 429      7473 00
 430               	.LASF18:
 431 0080 7465 7374 		.string	"test1.c"
 431      312E 6300 
 432               	.LASF5:
 433 0088 6C6F 6E67 		.string	"long unsigned int"
 433      2075 6E73 
 433      6967 6E65 
 433      6420 696E 
 433      7400 
 434               	.LASF7:
 435 009a 6C6F 6E67 		.string	"long long unsigned int"
 435      206C 6F6E 
 435      6720 756E 
 435      7369 676E 
 435      6564 2069 
 436               	.LASF12:
 437 00b1 7363 616E 		.string	"scanf"
 437      6600 
 438               	.LASF1:
 439 00b7 756E 7369 		.string	"unsigned char"
 439      676E 6564 
 439      2063 6861 
 439      7200 
 440               	.LASF10:
 441 00c5 6368 6172 		.string	"char"
 441      00
 442               	.LASF4:


 443 00ca 6C6F 6E67 		.string	"long int"
 443      2069 6E74 
 443      00
 444               	.LASF16:
 445 00d3 5F5F 6275 		.string	"__builtin_putchar"
 445      696C 7469 
 445      6E5F 7075 
 445      7463 6861 
 445      7200 
 446               	.LASF19:
 447 00e5 2F68 6F6D 		.string	"/home/students/5443962251"
 447      652F 7374 
 447      7564 656E 
 447      7473 2F35 
 447      3434 3339 
 448               	.LASF3:
 449 00ff 7368 6F72 		.string	"short unsigned int"
 449      7420 756E 
 449      7369 676E 
 449      6564 2069 
 449      6E74 00
 450               	.LASF0:
 451 0112 7369 676E 		.string	"signed char"
 451      6564 2063 
 451      6861 7200 
 452               	.LASF8:
 453 011e 6C6F 6E67 		.string	"long double"
 453      2064 6F75 
 453      626C 6500 
 454               	.LASF14:
 455 012a 5F5F 6275 		.string	"__builtin_scanf"
 455      696C 7469 
 455      6E5F 7363 
 455      616E 6600 
 456               	.LASF2:
 457 013a 7368 6F72 		.string	"short int"
 457      7420 696E 
 457      7400 
 458               		.ident	"GCC: (GNU) 11.4.0"


